<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>UniStudent新生报道系统</title>
    <url>/2022/09/10/UniStudent%20%E6%96%B0%E7%94%9F%E6%8A%A5%E9%81%93%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="unistudent新生报道系统">UniStudent新生报道系统</h1>
<p>2022-8-19 中软国际实训项目</p>
<blockquote>
<p>github项目：https://github.com/xclovehsy/uniStudent</p>
</blockquote>
<h2 id="项目简介">1. 项目简介</h2>
<p><strong>软件名称：</strong> UnitStudent新生报道系统</p>
<p><strong>软件应用：</strong>
该系统将主要面向重庆财经学院软件学院的2022级新生以及所有老师，使整个新生报道流程信息化，让新生和老师能够实时了解到新生报道的进行情况。
新生报道系统结合新生报到时的需求，利用网络的即时性，提高新生报到工作效率，减少报道所需，为报道的新生提供即时准确的报道相关信息，同时可以对自己的性格进行简单的测评，帮助新生进一步了解自己；
在帮助新生顺利完成报道的同时也为新生报到的规范化和信息化管理打坚实的基础。</p>
<h2 id="需求分析">2. 需求分析</h2>
<p><strong>需求范围：</strong> 重庆财经学院软件学院</p>
<p><strong>系统包括的功能范围：</strong></p>
<ol type="1">
<li>学校功能</li>
<li>查看新生报道实时进展</li>
<li>查看新生相关信息（专业，性别，地区，年龄）</li>
<li>查看新生职业性格大体分布</li>
</ol>
<p><strong>新生功能：</strong></p>
<ol type="1">
<li>填写自身相关信息</li>
<li>进行职业性格测试</li>
<li>查看报道流程</li>
<li>查看报道实时进展</li>
<li>查看新生相关信息（专业，性别，地区，年龄）</li>
<li>查看学校概况</li>
</ol>
<h2 id="运行环境">3. 运行环境</h2>
<p>本软件开发所使用的语言以及开发工具：</p>
<p>开发平台及工具；MySQL、Hbuilder X、Pycharm</p>
<p>通信协议：HTTP，TCP/IP</p>
<p>前端使用uniapp框架，后端使用python语言，fastapi进行接口的实现。</p>
<h2 id="项目预览">4. 项目预览</h2>
<h3 id="应用框架">4.1. 应用框架</h3>
<hr>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021443731.png" alt="image-20220902144331571">
<figcaption aria-hidden="true">image-20220902144331571</figcaption>
</figure>
<h3 id="流程图">4.2. 流程图</h3>
<hr>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021444357.png" alt="image-20220902144458239">
<figcaption aria-hidden="true">image-20220902144458239</figcaption>
</figure>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021446848.png" alt="image-20220902144602780">
<figcaption aria-hidden="true">image-20220902144602780</figcaption>
</figure>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021453406.png" alt="image-20220902145359327">
<figcaption aria-hidden="true">image-20220902145359327</figcaption>
</figure>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021454389.png" alt="image-20220902145410313">
<figcaption aria-hidden="true">image-20220902145410313</figcaption>
</figure>
<h3 id="项目界面">4.3. 项目界面</h3>
<h4 id="信息录入">4.3.1. 信息录入</h4>
<hr>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100813507.jpg" alt="Screenshot_20220909_212753_com.tencent.mm">
<figcaption aria-hidden="true">Screenshot_20220909_212753_com.tencent.mm</figcaption>
</figure>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100822778.jpg"></p>
<h4 id="信息总览">4.3.2. 信息总览</h4>
<hr>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100812240.jpg" alt="Screenshot_20220909_212208_com.tencent.mm">
<figcaption aria-hidden="true">Screenshot_20220909_212208_com.tencent.mm</figcaption>
</figure>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100812765.jpg" alt="Screenshot_20220909_212216_com.tencent.mm">
<figcaption aria-hidden="true">Screenshot_20220909_212216_com.tencent.mm</figcaption>
</figure>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100812753.jpg" alt="Screenshot_20220909_212225_com.tencent.mm">
<figcaption aria-hidden="true">Screenshot_20220909_212225_com.tencent.mm</figcaption>
</figure>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100813592.jpg" alt="Screenshot_20220909_212230_com.tencent.mm">
<figcaption aria-hidden="true">Screenshot_20220909_212230_com.tencent.mm</figcaption>
</figure>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100813636.jpg" alt="Screenshot_20220909_212240_com.tencent.mm">
<figcaption aria-hidden="true">Screenshot_20220909_212240_com.tencent.mm</figcaption>
</figure>
<h4 id="数据面板">4.3.3. 数据面板</h4>
<hr>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100814029.jpg" alt="Screenshot_20220909_212823_com.tencent.mm">
<figcaption aria-hidden="true">Screenshot_20220909_212823_com.tencent.mm</figcaption>
</figure>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100814845.jpg" alt="Screenshot_20220909_212828_com.tencent.mm">
<figcaption aria-hidden="true">Screenshot_20220909_212828_com.tencent.mm</figcaption>
</figure>
<h4 id="新生指南">4.3.4. 新生指南</h4>
<hr>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100813181.jpg" alt="Screenshot_20220909_212342_com.tencent.mm">
<figcaption aria-hidden="true">Screenshot_20220909_212342_com.tencent.mm</figcaption>
</figure>
<h4 id="性格测试">4.3.5. 性格测试</h4>
<hr>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100814203.jpg" alt="Screenshot_20220909_212354_com.tencent.mm">
<figcaption aria-hidden="true">Screenshot_20220909_212354_com.tencent.mm</figcaption>
</figure>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100814152.jpg" alt="Screenshot_20220909_212613_com.tencent.mm">
<figcaption aria-hidden="true">Screenshot_20220909_212613_com.tencent.mm</figcaption>
</figure>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100814481.jpg" alt="Screenshot_20220909_212627_com.tencent.mm">
<figcaption aria-hidden="true">Screenshot_20220909_212627_com.tencent.mm</figcaption>
</figure>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100814850.jpg" alt="Screenshot_20220909_212642_com.tencent.mm">
<figcaption aria-hidden="true">Screenshot_20220909_212642_com.tencent.mm</figcaption>
</figure>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100814057.jpg" alt="Screenshot_20220909_212702_com.tencent.mm">
<figcaption aria-hidden="true">Screenshot_20220909_212702_com.tencent.mm</figcaption>
</figure>
<h4 id="大数据面板">4.3.6. 大数据面板</h4>
<hr>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021514993.jpg" alt="image-20220902150435623">
<figcaption aria-hidden="true">image-20220902150435623</figcaption>
</figure>
<h2 id="程序入口">5. 程序入口</h2>
<p><strong>程序入口二维码：</strong></p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209102321648.jpg" alt="-170c280b23612a5c">
<figcaption aria-hidden="true">-170c280b23612a5c</figcaption>
</figure>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209102321486.jpg" alt="-1bf9d8e9c0a82e3">
<figcaption aria-hidden="true">-1bf9d8e9c0a82e3</figcaption>
</figure>
<blockquote>
<p>大数据面板：http://v.yuntus.com/tcv/0590A5ac63f90BA555CE76d4686F0772</p>
</blockquote>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>uniapp</tag>
      </tags>
  </entry>
  <entry>
    <title>STL技巧</title>
    <url>/2024/07/30/STL/</url>
    <content><![CDATA[<h1 id="stl技巧">STL技巧</h1>
<h2 id="vector数组">vector数组</h2>
<p>变长数组，倍增的思想</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">size</span>()  返回元素个数</span><br><span class="line"><span class="built_in">empty</span>()  返回是否为空</span><br><span class="line"><span class="built_in">clear</span>()  清空</span><br><span class="line"><span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line"><span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line"><span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">[]</span><br><span class="line">\\ 支持比较运算，按字典序</span><br></pre></td></tr></table></figure>
<h2 id="pairint-int二元组">pair&lt;int, int&gt;二元组</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">first, 第一个元素</span><br><span class="line">second, 第二个元素</span><br><span class="line">支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br></pre></td></tr></table></figure>
<h2 id="string字符串">string字符串</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">size</span>()/<span class="built_in">length</span>()  返回字符串长度</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">clear</span>()</span><br><span class="line"><span class="built_in">substr</span>(起始下标，(子串长度))  返回子串</span><br><span class="line"><span class="built_in">c_str</span>()  返回字符串所在字符数组的起始地址</span><br></pre></td></tr></table></figure>
<h2 id="queue队列">queue队列</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">push</span>()  向队尾插入一个元素</span><br><span class="line"><span class="built_in">front</span>()  返回队头元素</span><br><span class="line"><span class="built_in">back</span>()  返回队尾元素</span><br><span class="line"><span class="built_in">pop</span>()  弹出队头元素</span><br></pre></td></tr></table></figure>
<h2 id="priority_queue优先队列">priority_queue优先队列</h2>
<p>默认是大根堆 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">push</span>()  \\ 插入一个元素</span><br><span class="line"><span class="built_in">top</span>()  返回堆顶元素</span><br><span class="line"><span class="built_in">pop</span>()  弹出堆顶元素</span><br><span class="line">定义成小根堆的方式：priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure></p>
<h2 id="stack栈">stack栈</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">push</span>()  向栈顶插入一个元素</span><br><span class="line"><span class="built_in">top</span>()  返回栈顶元素</span><br><span class="line"><span class="built_in">pop</span>()  弹出栈顶元素</span><br></pre></td></tr></table></figure>
<h2 id="deque双端队列">deque双端队列</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">clear</span>()</span><br><span class="line"><span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line"><span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line"><span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line"><span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<h2 id="set集合map字典">set集合&amp;map字典</h2>
<p>基于平衡二叉树（红黑树），动态维护有序序列 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">clear</span>()</span><br><span class="line"><span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">++, -- 返回前驱和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br></pre></td></tr></table></figure></p>
<h3 id="setmultiset">set&amp;multiset</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">insert</span>()  插入一个数</span><br><span class="line"><span class="built_in">find</span>()  查找一个数</span><br><span class="line"><span class="built_in">count</span>()  返回某一个数的个数</span><br><span class="line"><span class="built_in">erase</span>()</span><br><span class="line">    (<span class="number">1</span>) 输入是一个数x，删除所有<span class="function">x   <span class="title">O</span><span class="params">(k + logn)</span></span></span><br><span class="line"><span class="function">    <span class="params">(<span class="number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function"><span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">lower_bound</span><span class="params">(x)</span>  返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">    <span class="title">upper_bound</span><span class="params">(x)</span>  返回大于x的最小的数的迭代器</span></span><br></pre></td></tr></table></figure>
<h3 id="mapmultimap">map&amp;multimap</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">insert</span>()  插入的数是一个<span class="function">pair</span></span><br><span class="line"><span class="function"><span class="title">erase</span><span class="params">()</span>  输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">[]  注意multimap不支持此操作。 时间复杂度是 <span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function"><span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h2 id="unordered哈希表">unordered哈希表</h2>
<ul>
<li><p>unordered_set</p></li>
<li><p>unordered_map</p></li>
<li><p>unordered_multiset</p></li>
<li><p>unordered_multimap</p></li>
</ul>
<p>和上面类似，增删改查的时间复杂度是 O(1) 不支持
lower_bound()/upper_bound()， 迭代器的++，--</p>
<h2 id="bitset圧位">bitset圧位</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bitset&lt;10000&gt; s;</span><br><span class="line">~, &amp;, |, ^</span><br><span class="line">&gt;&gt;, &lt;&lt;</span><br><span class="line">==, !=</span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line"><span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line"><span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line"><span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line"><span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line"><span class="built_in">flip</span>()  等价于~</span><br><span class="line"><span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>git指令</title>
    <url>/2022/09/09/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="git指令">git指令</h1>
<h2 id="仓库管理">仓库管理</h2>
<h3 id="初始化仓库">初始化仓库</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h3 id="添加删除文件">添加/删除文件</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add/rm [filename]</span><br><span class="line">git add . # 添加所有文件</span><br></pre></td></tr></table></figure>
<h3 id="提交代码到本地仓库">提交代码到本地仓库</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;commit file</span><br></pre></td></tr></table></figure>
<h3 id="查看仓库状态">查看仓库状态</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<h3 id="添加远程仓库url">添加远程仓库url</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin [repository url]</span><br></pre></td></tr></table></figure>
<h3 id="同步本地仓库代码">同步本地仓库代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>
<h3 id="上传代码到远程仓库">上传代码到远程仓库</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一次提交</span><br><span class="line"># 将本地的master分支和远程仓库origin的master分支关联</span><br><span class="line">git push -u origin master   </span><br><span class="line"></span><br><span class="line"># 经常使用</span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"># 强行提交，谨慎使用 </span><br><span class="line"># f表示force</span><br><span class="line">git push origin master -f </span><br></pre></td></tr></table></figure>
<h2 id="分支管理">分支管理</h2>
<h3 id="本地操作">本地操作</h3>
<h4 id="查看分支">查看分支</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line"></span><br><span class="line"># 查看所用分支，以及其关联的远程分支</span><br><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<h4 id="创建分支">创建分支</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch [branch name]</span><br></pre></td></tr></table></figure>
<h4 id="切换分支">切换分支</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout [branch name]</span><br></pre></td></tr></table></figure>
<h4 id="分支快速创建和切换">分支快速创建和切换</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b [branch name]</span><br></pre></td></tr></table></figure>
<h4 id="分支合并">分支合并</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 首先需要切换到合并的主分支上去</span><br><span class="line">git merge [branch name]</span><br></pre></td></tr></table></figure>
<p><strong>遇到冲突时的分支合并</strong>
如果在两个不同的分支中，对同一个文件进行了不同的修改，Git
就没法干净的合并它们。
此时，我们需要打开这些包含冲突的文件然后手动解决冲突。</p>
<h4 id="删除分支">删除分支</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d [branch name]</span><br></pre></td></tr></table></figure>
<h3 id="远程操作">远程操作</h3>
<h4 id="查看远程仓库分支">查看远程仓库分支</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote show [repository name]</span><br></pre></td></tr></table></figure>
<h4 id="本地分支推送到远程仓库分支">本地分支推送到远程仓库分支</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -u 表示把本地分支和远程分支进行关联，只在第一次推送的时候需要带 -u 参数</span><br><span class="line">git push -u 远程仓库的别名 本地分支名称: 远程分支名称</span><br><span class="line"></span><br><span class="line"># 案例</span><br><span class="line">git push -u origin payment:pay</span><br><span class="line"></span><br><span class="line"># 如果希望远程分支的名称和本地分支名称保持一直，可以对命令进行简化：</span><br><span class="line">git push -u origin payment</span><br></pre></td></tr></table></figure>
<h4 id="跟踪分支">跟踪分支</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从远程仓库中，把对应的远程分支下载到本地仓库，名字保持一致</span><br><span class="line">git checkout 远程分支的名称</span><br><span class="line"></span><br><span class="line"># 从远程仓库中，把对应的远程分支下载到本地仓库，并把下载的本地分支进行重命名</span><br><span class="line">git checkout -b 本地分支名称 远程仓库名称/远程分支名称</span><br><span class="line"></span><br><span class="line"># 案例  把远程仓库origin里面的pay分支下载并重命名为payment分支</span><br><span class="line">git checkout -b payment origin/pay</span><br></pre></td></tr></table></figure>
<h4 id="拉取远程分支最新代码">拉取远程分支最新代码</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
<h4 id="删除远程分支">删除远程分支</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin --delete [branch name]</span><br></pre></td></tr></table></figure>
<h2 id="代理设置">代理设置</h2>
<p>在执行<code>git clone</code>时，该方法只适用于http方式，不适用于ssh方式。</p>
<p>ssh方式推荐使用proxychains(linux)。</p>
<h3 id="socks代理">socks代理</h3>
<p>在<code>参数设置</code>-<code>Core:基础设置</code>中可以查看本地<code>socks</code>端口号，一般为1080。</p>
<p>在命令行中使用以下命令设置git代理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>
<h3 id="http代理">http代理</h3>
<p>把v2rayN设为全局模式，打开win10的设置中代理，可以看到<code>socks</code>端口号。</p>
<p>在命令行中使用以下命令设置git代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:1081</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1081</span><br></pre></td></tr></table></figure>
<h3 id="取消代理">取消代理</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>常用技巧</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-2182-线段树模板题</title>
    <url>/2023/10/24/poj2182/</url>
    <content><![CDATA[<h1 id="poj-2182-线段树模板题">POJ-2182-线段树模板题</h1>
<h2 id="题目描述">题目描述</h2>
<p>N (2 &lt;= N &lt;= 8,000) cows have unique brands in the range 1..N.
In a spectacular display of poor judgment, they visited the neighborhood
'watering hole' and drank a few too many beers before dinner. When it
was time to line up for their evening meal, they did not line up in the
required ascending numerical order of their brands.</p>
<p>Regrettably, FJ does not have a way to sort them. Furthermore, he's
not very good at observing problems. Instead of writing down each cow's
brand, he determined a rather silly statistic: For each cow in line, he
knows the number of cows that precede that cow in line that do, in fact,
have smaller brands than that cow.</p>
<p>Given this data, tell FJ the exact ordering of the cows.</p>
<h2 id="示例">示例</h2>
<h3 id="input">Input</h3>
<p>Line 1: A single integer, N</p>
<p>Lines 2..N: These N-1 lines describe the number of cows that precede
a given cow in line and have brands smaller than that cow. Of course, no
cows precede the first cow in line, so she is not listed. Line 2 of the
input describes the number of preceding cows whose brands are smaller
than the cow in slot #2; line 3 describes the number of preceding cows
whose brands are smaller than the cow in slot #3; and so on.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="output">Output</h3>
<p>Lines 1..N: Each of the N lines of output tells the brand of a cow in
line. Line #1 of the output tells the brand of the first cow in line;
line 2 tells the brand of the second cow; and so on.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="ac代码">AC代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 左移乘法，右移除法</span></span><br><span class="line"><span class="comment">    2. 移1位表示 *or/2，移2位表示 *or/4</span></span><br><span class="line"><span class="comment">    3. 移位运算一定要加括号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="comment">// len表示当前节点的长度</span></span><br><span class="line">    <span class="keyword">int</span> l, r, len; </span><br><span class="line">&#125;tree[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> pre[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立线段树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    tree[root].l = left; tree[root].r = right;</span><br><span class="line">    tree[root].len = right-left+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(left == right) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">build_tree</span>(root&lt;&lt;<span class="number">1</span>, left, (left+right)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build_tree</span>((root&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, ((left+right)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找当前节点下第k大的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quary</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    tree[root].len--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tree[root].l == tree[root].r) <span class="keyword">return</span> tree[root].l;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果左子树节点数量小于k，则从右子树寻找第 k-tree[root&lt;&lt;2].len 个元素</span></span><br><span class="line">    <span class="keyword">if</span>(tree[root&lt;&lt;<span class="number">1</span>].len&lt;k) <span class="keyword">return</span> <span class="built_in">quary</span>((root&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, k-tree[root&lt;&lt;<span class="number">1</span>].len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果大于k，表示左子树节点数量足够，继续从左子树寻找</span></span><br><span class="line">    <span class="keyword">if</span>(tree[root&lt;&lt;<span class="number">1</span>].len &gt;= k) <span class="keyword">return</span> <span class="built_in">quary</span>(root&lt;&lt;<span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pre[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build_tree</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        ans[i] = <span class="built_in">quary</span>(<span class="number">1</span>, pre[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">0 1 2 1 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://poj.org/problem?id=2182">2182 -- Lost Cows
(poj.org)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-3468</title>
    <url>/2023/10/25/poj3468/</url>
    <content><![CDATA[<h1 id="poj-3468">POJ-3468</h1>
<h2 id="题目描述">题目描述</h2>
<p>You have <em>N</em> integers, <em>A</em>1, <em>A</em>2, ... ,
<em>AN</em>. You need to deal with two kinds of operations. One type of
operation is to add some given number to each number in a given
interval. The other is to ask for the sum of numbers in a given
interval.</p>
<h2 id="示例">示例</h2>
<h3 id="input">Input</h3>
<p>The first line contains two numbers <em>N</em> and <em>Q</em>. 1 ≤
<em>N</em>,<em>Q</em> ≤ 100000. The second line contains <em>N</em>
numbers, the initial values of <em>A</em>1, <em>A</em>2, ... ,
<em>AN</em>. -1000000000 ≤ <em>Ai</em> ≤ 1000000000. Each of the next
<em>Q</em> lines represents an operation. "C <em>a</em> <em>b</em>
<em>c</em>" means adding <em>c</em> to each of <em>Aa</em>,
<em>Aa</em>+1, ... , <em>Ab</em>. -10000 ≤ <em>c</em> ≤ 10000. "Q
<em>a</em> <em>b</em>" means querying the sum of <em>Aa</em>,
<em>Aa</em>+1, ... , <em>Ab</em>.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 5</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">Q 4 4</span><br><span class="line">Q 1 10</span><br><span class="line">Q 2 4</span><br><span class="line">C 3 6 3</span><br><span class="line">Q 2 4</span><br></pre></td></tr></table></figure>
<h3 id="output">Output</h3>
<p>You need to answer all <em>Q</em> commands in order. One answer in a
line.</p>
<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">55</span><br><span class="line">9</span><br><span class="line">15</span><br></pre></td></tr></table></figure>
<p><strong>Hint</strong></p>
<p>The sums may exceed the range of 32-bit integers.</p>
<h2 id="ac代码">AC代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max = <span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson rt&lt;&lt;1, l, mid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson (rt&lt;&lt;1)+1, mid+1, r</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    ll sum,add;</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;tree[Max&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;   <span class="comment">// 从下往上更新sum</span></span><br><span class="line">    tree[rt].sum = tree[rt&lt;&lt;<span class="number">1</span>].sum+tree[(rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123; <span class="comment">// 向下更新add和sum</span></span><br><span class="line">    <span class="keyword">if</span>(tree[rt].add!=<span class="number">0</span>)&#123;</span><br><span class="line">        tree[rt&lt;&lt;<span class="number">1</span>].add += tree[rt].add;</span><br><span class="line">        tree[(rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].add += tree[rt].add;</span><br><span class="line">        tree[rt&lt;&lt;<span class="number">1</span>].sum += (tree[rt&lt;&lt;<span class="number">1</span>].r-tree[rt&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>)*tree[rt].add;</span><br><span class="line">        tree[(rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].sum += (tree[(rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].r-tree[(rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].l+<span class="number">1</span>)*tree[rt].add;</span><br><span class="line">        tree[rt].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;   <span class="comment">// 建线段树</span></span><br><span class="line">    tree[rt].l = l; tree[rt].r = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;tree[rt].sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lson);</span><br><span class="line">    <span class="built_in">build</span>(rson);</span><br><span class="line">    <span class="built_in">push_up</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> a, <span class="keyword">int</span> b, ll c)</span></span>&#123;   <span class="comment">// 【a, b】区间每个数+c，使用lazy</span></span><br><span class="line">    <span class="keyword">if</span>(tree[rt].l&gt;=a &amp;&amp; tree[rt].r&lt;=b)&#123; <span class="comment">// 如果更新的区间 包含了 当前节点的区间</span></span><br><span class="line">        tree[rt].sum += (tree[rt].r-tree[rt].l+<span class="number">1</span>)*c;</span><br><span class="line">        tree[rt].add += c;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">push_down</span>(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[rt].l+tree[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= mid) <span class="built_in">update</span>(rt&lt;&lt;<span class="number">1</span>, a, b, c);</span><br><span class="line">    <span class="keyword">if</span>(b &gt; mid) <span class="built_in">update</span>((rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, a, b, c);</span><br><span class="line">    <span class="built_in">push_up</span>(rt);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quary</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;   <span class="comment">// 查询【Na, Nb】区间和</span></span><br><span class="line">    <span class="keyword">if</span>(tree[rt].l&gt;=a &amp;&amp; tree[rt].r&lt;=b)&#123; <span class="comment">// 如果更新的区间 包含了 当前节点的区间</span></span><br><span class="line">        <span class="keyword">return</span> tree[rt].sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">push_down</span>(rt);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[rt].l+tree[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= mid) ans += <span class="built_in">quary</span>(rt&lt;&lt;<span class="number">1</span>, a, b);</span><br><span class="line">    <span class="keyword">if</span>(b &gt; mid) ans += <span class="built_in">quary</span>((rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q, a, b;</span><br><span class="line">    ll c;</span><br><span class="line">    <span class="keyword">char</span> qu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cin &gt;&gt; n &gt;&gt; q;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n,&amp;q);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;qu);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(qu == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">quary</span>(<span class="number">1</span>, a, b));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;a,&amp;b, &amp;c);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, a, b, c);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 5</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line"><span class="comment">Q 4 4</span></span><br><span class="line"><span class="comment">Q 1 10</span></span><br><span class="line"><span class="comment">Q 2 4</span></span><br><span class="line"><span class="comment">C 3 6 3</span></span><br><span class="line"><span class="comment">Q 2 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">10 2</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line"><span class="comment">C 3 6 3</span></span><br><span class="line"><span class="comment">Q 2 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://poj.org/problem?id=3468">3468 -- A Simple Problem
with Integers (poj.org)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>区间求和</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用指令</title>
    <url>/2022/09/09/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="linux常用指令">Linux常用指令</h1>
<h2 id="档案与目录管理">档案与目录管理</h2>
<h3 id="切换路径">切换路径</h3>
<h4 id="绝对路径">绝对路径</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 绝对路径，路径前+“/” 表示绝对路径</span><br><span class="line">cd /home/xc  </span><br></pre></td></tr></table></figure>
<h4 id="相对路径">相对路径</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd test </span><br></pre></td></tr></table></figure>
<h4 id="显示当前路径">显示当前路径</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>
<h4 id="清空终端信息">清空终端信息</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure>
<h3 id="显示文件列表">显示文件列表</h3>
<h4 id="当前目录下的文件目录名">当前目录下的文件、目录名</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>
<h4 id="文件目录的详细信息">文件、目录的详细信息</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ll</span><br></pre></td></tr></table></figure>
<h4 id="指定文件名">指定文件名</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 当前目录下含有“test”的目录以及其详细信息</span><br><span class="line">ll test*</span><br></pre></td></tr></table></figure>
<h3 id="文件目录管理">文件目录管理</h3>
<h4 id="创建目录">创建目录</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir [list name]	</span><br></pre></td></tr></table></figure>
<h4 id="删除空目录">删除空目录</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmdir [list name]	</span><br></pre></td></tr></table></figure>
<h4 id="删除文件">删除文件</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文件名需要和ls中的对应</span><br><span class="line">rm [file name] 	</span><br></pre></td></tr></table></figure>
<h4 id="删除非空目录">删除非空目录</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 目录可不为空 </span><br><span class="line"># r-表示循环 f-表示force强力</span><br><span class="line">rm -rf [list name]	</span><br></pre></td></tr></table></figure>
<h4 id="复制目录或文件">复制目录或文件</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 复制文件 </span><br><span class="line"># 相对路径 or 绝对路径</span><br><span class="line">cp -r [origin file path] [destination file path]</span><br><span class="line"></span><br><span class="line"># 复制目录 </span><br><span class="line"># 相对路径 or 绝对路径</span><br><span class="line">cp -r [origin list path] [destination file path]</span><br></pre></td></tr></table></figure>
<h4 id="移动目录或文件">移动目录或文件</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 移动文件 </span><br><span class="line"># 相对路径 or 绝对路径</span><br><span class="line">mv [origin file path] [destination file path]</span><br><span class="line"></span><br><span class="line"># 移动目录 </span><br><span class="line"># 相对路径 or 绝对路径</span><br><span class="line">mv [origin list path] [destination file path]</span><br></pre></td></tr></table></figure>
<h2 id="管理文件">管理文件</h2>
<h3 id="创建文件">创建文件</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在当前路径下创建一个名为[file name]的文件, 需要后缀</span><br><span class="line">touch [file name] 	</span><br></pre></td></tr></table></figure>
<h3 id="查看文件">查看文件</h3>
<h4 id="显示文件内容">显示文件内容</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat [file name]</span><br></pre></td></tr></table></figure>
<h4 id="显示文件源码内容">显示文件源码内容</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat -A [file name]</span><br></pre></td></tr></table></figure>
<h4 id="按行显示">按行显示</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一行一行显示文件内容</span><br><span class="line">more [file name]</span><br><span class="line"></span><br><span class="line"># 一行一行显示文件内容（可以翻页，但是没找到关闭的方式..）</span><br><span class="line">less [file name]</span><br></pre></td></tr></table></figure>
<h4 id="显示部分内容">显示部分内容</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示文件头几行，n表示显示的行数</span><br><span class="line">head -n [file name]	</span><br><span class="line"></span><br><span class="line"># 显示文件尾几行，n表示显示的行数</span><br><span class="line">tail -n [file name]	</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>常用技巧</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客搭建</title>
    <url>/2022/09/08/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="hexo博客搭建">hexo博客搭建</h1>
<h2 id="推送博客文件">推送博客文件</h2>
<h3 id="清空之前的文件">清空之前的文件</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<h3 id="生成静态文章">生成静态文章</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"># 简写</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<h3 id="部署博客">部署博客</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy </span><br><span class="line"></span><br><span class="line"># 简写 </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h2 id="本地测试">本地测试</h2>
<h3 id="生成静态文件">生成静态文件</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<h3 id="打开本地服务器">打开本地服务器</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<h2 id="写文章">写文章</h2>
<h3 id="新建文章">新建文章</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;title&quot;</span><br></pre></td></tr></table></figure>
<h3 id="新建草稿文件">新建草稿文件</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new draft &quot;title&quot;</span><br></pre></td></tr></table></figure>
<h3 id="新建界面">新建界面</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;title&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>常用技巧</category>
      </categories>
      <tags>
        <tag>-hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2024/07/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="动态规划">动态规划</h1>
<h2 id="背包问题">背包问题</h2>
<h3 id="背包">0-1背包</h3>
<p>转移方程：<span class="math inline">\(dp[i][j]=max(dp[i-1][j],
dp[i-1][j-v[i]]+w[i])\)</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> v[N], w[N], dp[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[i][j] 为考虑1-i个物品，背包容积为j时的最大价值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= v[i]) dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j-v[i]]+w[i], dp[i<span class="number">-1</span>][j]); </span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在计算 <span class="math inline">\(dp[i][j]\)</span>
时，只会用到<span class="math inline">\(dp[i-1][j]\)</span>，不会用到比<span class="math inline">\(i\)</span>更早的状态。</p>
<p>因此可以考虑因此可以去掉第一个维度，反复利用同一个一维数组。</p>
<p>转移方程：$dp[j] = max(dp[j], dp[i-1][j-v[i]]+w[i]) $</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> v[N], w[N], dp[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= <span class="number">1</span>; j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= v[i]) dp[j] = <span class="built_in">max</span>(dp[j-v[i]]+w[i], dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完全背包">完全背包</h3>
<p>转移方程：<span class="math inline">\(dp[i][j]=max(dp[i-1][j],
dp[i][j-v[i]]+w[i])\)</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> v[N], w[N], dp[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= v[i]) dp[i][j] = <span class="built_in">max</span>(dp[i][j-v[i]]+w[i], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多重背包">多重背包</h3>
<p>转移方程：<span class="math inline">\(dp[i][j]=max(dp[i-1][j],
dp[i-1][j-k*v[i]]+w[i]*k), k=0,1,..,s[i]\)</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> v[N], w[N], s[N], dp[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; v[i]*k &lt;= j; k++) </span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i<span class="number">-1</span>][j-v[i]*k]+k*w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分组背包">分组背包</h3>
<p>每组物品有若干个，同一组内的物品最多只能选一个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s[i] 第i组物品个数</span></span><br><span class="line"><span class="comment">// v[i][j] i组中第j个物品的体积</span></span><br><span class="line"><span class="comment">// w[i][j] i组中第j个物品的价值</span></span><br><span class="line"><span class="keyword">int</span> s[N], v[N][N], w[N][N], dp[N][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;  <span class="comment">// 遍历组编号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)&#123;	<span class="comment">// 遍历背包容积</span></span><br><span class="line">        dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=s[i]; k++)&#123;  <span class="comment">// 遍历组内物品</span></span><br><span class="line">            <span class="keyword">if</span>(v[i][k] &lt;= j) </span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i<span class="number">-1</span>][j-v[i][k]]+w[i][k]);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线性dp">线性DP</h2>
<ul>
<li>子序列不要求在原序列中连续</li>
<li>字串要求连续</li>
</ul>
<h3 id="杨辉三角">杨辉三角</h3>
<h3 id="最长递增子序列">最长递增子序列</h3>
<p>给定一个长度为 N
的数列，求数值严格单调递增的子序列的长度最长是多少。</p>
<p>初始化 <span class="math inline">\(dp[i] = 1, (i=1,..,n)\)</span>
表示以<span class="math inline">\(nums[i]\)</span>
结尾的最长单调递增子序列的长度</p>
<p><span class="math inline">\(dp[i] = \underset{j&lt;i\ and\ nums[j]
&lt; nums[i]}{max}\{dp[j] + 1\}\)</span></p>
<p><span class="math inline">\(ans =
max(dp[1],dp[2],...,dp[n])\)</span></p>
<p>时间复杂度<span class="math inline">\(O(n^2)\)</span></p>
<blockquote>
<p>n大于<span class="math inline">\(1e^5\)</span>时 <span class="math inline">\(O(n^2)\)</span>时间复杂度会导致超时</p>
</blockquote>
<p>定义<span class="math inline">\(dp[i]\)</span>表示长度为<span class="math inline">\(i+1\)</span>的最长递增子序列最后一个数字的最小值</p>
<p>利用<span class="math inline">\(dp\)</span>数组的单调性，通过二分查找找到大于等于<span class="math inline">\(nums[i]\)</span>位置</p>
<p>时间复杂度<span class="math inline">\(O(n^2)\)</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N], nums[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nums[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">0</span> || dp[ans<span class="number">-1</span>] &lt; nums[i]) dp[ans++] = nums[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = ans<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid] &gt;= nums[i]) r = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[l] &gt; nums[i]) dp[l] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长公共子序列">最长公共子序列</h3>
<p>给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B
的子序列的字符串长度最长是多少。</p>
<p><span class="math inline">\(dp[i][j]\)</span> 表示字符串$A[0:i] <span class="math inline">\(与\)</span>B[0:j]$的最长公共子序列长度</p>
<p>初始化: <span class="math inline">\(dp[i][j] = 0\)</span>
任何序列和空串的最长公共子序列长度都为0</p>
<p>转移方程:</p>
<p>（1）<span class="math inline">\(A[i]=B[i]\)</span> 时，<span class="math inline">\(dp[i][j] = dp[i-1][j-1] + 1\)</span></p>
<p>（2）<span class="math inline">\(A[i]\neq B[i]\)</span> 时，<span class="math inline">\(dp[i][j] = max(dp[i-1][j],
dp[i][j-1])\)</span></p>
<h3 id="编辑距离">编辑距离</h3>
<p>给出字符串A和B，求将A转换成B所使用的最少操作数</p>
<p>对每个字符可进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><span class="math inline">\(dp[i][j]\)</span> 表示字符串<span class="math inline">\(A[0:i]\)</span>变成<span class="math inline">\(B[0:j]\)</span>的最少操作数（重点关注各自的最后字符）</p>
<p>初始化： （任何序列和空串的编辑距离均为序列长度）</p>
<ul>
<li><span class="math inline">\(dp[i][0]=i,(i=1,2,..,n)\)</span></li>
<li><span class="math inline">\(dp[0][j]=j,(j=1,2,...,n)\)</span></li>
</ul>
<p>转移方程</p>
<p><span class="math inline">\(if\ A[i]==B[i],\ dp[i][j] =
dp[i-1][j-1]\)</span></p>
<p><span class="math inline">\(else\ dp[i][j]=min(dp[i-1][j],
dp[j][i-1], dp[i-1][j-1]) + 1\)</span></p>
<p>其中</p>
<ul>
<li><span class="math inline">\(dp[i-1][j],dp[i][j-1]\)</span>
可以看成插入或者删除一个字符</li>
<li><span class="math inline">\(dp[i-1][j-1]\)</span>为交换两个字符</li>
</ul>
<h2 id="区间dp">区间DP</h2>
<p>所有的区间dp问题枚举时，第一维通常是枚举区间长度，并且一般 len = 1
时用来初始化，枚举从 len = 2 开始；第二维枚举起点 i （右端点 j
自动获得，j = i + len - 1）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; len++) &#123;         <span class="comment">// 区间长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123; <span class="comment">// 枚举起点</span></span><br><span class="line">        <span class="keyword">int</span> j = i + len - <span class="number">1</span>;                 <span class="comment">// 区间终点</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) dp[i][j] = 初始值</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">        	 <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;        <span class="comment">// 枚举分割点，构造状态转移方程</span></span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + w[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="石头合并">石头合并</h3>
<p>合并 N 堆石子，每次只能合并相邻的两堆石子，求最小代价</p>
<p>（最后一次合并一定是左边连续的一部分和右边连续的一部分进行合并）</p>
<p><span class="math inline">\(dp[i][j]\)</span> 表示将 𝑖 到 𝑗
这一段石子合并成一堆的方案的集合，属性 Min</p>
<p>利用前缀和计算区间和</p>
<p>转移方程：</p>
<ol type="1">
<li><p><span class="math inline">\(i&lt;j\)</span> 时，<span class="math inline">\(dp[i][j] = \underset{i\le k\le j-1}{min}
\{dp[i][k] + dp[k+1][j] + s[j] - s[i-1]\}\)</span></p></li>
<li><p><span class="math inline">\(i=j\)</span> 时， <span class="math inline">\(dp[i][j] = 0\)</span> （合并一堆石子代价为
0）</p></li>
</ol>
<h2 id="计数类dp">计数类DP</h2>
<h3 id="整数划分">整数划分</h3>
<p>一个正整数n可以表示成若干个正整数之和，形如：<span class="math inline">\(n=n_1+n_2+…+n_k\)</span>，其中<span class="math inline">\(n_1≥n_2≥…≥n_k,k≥1\)</span>。</p>
<p>这样的一种表示称为正整数n的一种划分。给定一个正整数n，求出n共有多少种不同的划分方法。</p>
<blockquote>
<p>完全背包的解法 <span class="math inline">\(O(n^3)\)</span></p>
</blockquote>
<p>状态定义: <span class="math inline">\(dp[i][j]\)</span>
从1-i中选体积刚好为j的方案数量,</p>
<p>状态计算： <span class="math inline">\(dp[i][j] = \underset{k*i\le
j}{\sum} \{dp[i-1][j-i*k]\}\)</span></p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/blogImg/image-20240730131454674.png" alt="image-20240730131454674">
<figcaption aria-hidden="true">image-20240730131454674</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[N][N]; <span class="comment">// dp[i][j] 从1-i中选体积刚好为j的方案数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 一个数也不选也是一种方案</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; j - k * i &gt;= <span class="number">0</span>; k++)&#123;</span><br><span class="line">            dp[i][j] += dp[i<span class="number">-1</span>][j - i*k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>完全背包优化 <span class="math inline">\(O(n^2)\)</span></p>
</blockquote>
<p><span class="math inline">\(dp[i][j] =
dp[i-1][j]+dp[i-1][j-i]+dp[i-1][j-2i]+dp[i-1][j-3i]+...+dp[i-1][j-ki]\)</span></p>
<p><span class="math inline">\(dp[i][j-i] = \ \ \ \ \ \ \ \ \ \ \ \ \ \
\ \ \
dp[i-1][j-i]+dp[i-1][j-2i]+dp[i-1][j-3i]+...+dp[i-1][j-ki]\)</span></p>
<p>将<span class="math inline">\(dp[i][j-i]\)</span>代入 <span class="math inline">\(dp[i][j]\)</span> 得到 <span class="math inline">\(dp[i][j] = dp[i-1][j]+dp[i][j-i]\)</span></p>
<p>优化一维：<span class="math inline">\(dp[j] =
dp[j]+dp[j-i]\)</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j++)&#123;</span><br><span class="line">        dp[j] = dp[j] + dp[j - i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>计数DP方案</p>
</blockquote>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/blogImg/image-20240730135056199.png" alt="image-20240730135056199">
<figcaption aria-hidden="true">image-20240730135056199</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">        dp[i][j] = (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - j][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) res += dp[n][i];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="数位统计dp">数位统计DP</h2>
<h2 id="状态压缩dp">状态压缩DP</h2>
<h2 id="树形dp">树形DP</h2>
<h2 id="记忆化搜索">记忆化搜索</h2>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法</title>
    <url>/2024/07/30/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="基础算法">基础算法</h1>
<h2 id="常用头文件">常用头文件</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> vector &lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">5</span>, MAXM=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br></pre></td></tr></table></figure>
<h2 id="排序">排序</h2>
<h3 id="快速排序">快速排序</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x = nums[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(nums[i] &lt; x); </span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(nums[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(nums, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(nums, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.acwing.com/problem/content/787/">785. 快速排序 -
AcWing题库</a></p>
</blockquote>
<h3 id="归并排序">归并排序</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[j]) tmp[idx++] = nums[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[idx++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[idx++] = nums[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[idx++] = nums[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) nums[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.acwing.com/problem/content/789/">787. 归并排序 -
AcWing题库</a></p>
</blockquote>
<h2 id="二分查找">二分查找</h2>
<h3 id="整数二分查找">整数二分查找</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bSearch</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bSearch</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.acwing.com/problem/content/791/">789. 数的范围 -
AcWing题库</a></p>
<p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34.
在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></p>
</blockquote>
<h3 id="浮点数二分查找">浮点数二分查找</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">bSearch</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)&#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.acwing.com/problem/content/792/">790.
数的三次方根 - AcWing题库</a></p>
<h2 id="高精度计算">高精度计算</h2>
<h3 id="高精度加法">高精度加法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">addLargeNum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">addLargeNum</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )&#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.acwing.com/problem/content/793/">791. 高精度加法
- AcWing题库</a></p>
</blockquote>
<h3 id="高精度减法">高精度减法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0， 判断大小 长度-字典序</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )&#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度乘低精度">高精度乘低精度</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="高精度除以低精度">高精度除以低精度</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )&#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前缀和差分">前缀和&amp;差分</h2>
<h3 id="一维前缀和">一维前缀和</h3>
<p>已知一维数组，计算某个区间的和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[N];	<span class="comment">// 原数组  下标从1开始，方便计算</span></span><br><span class="line"><span class="keyword">int</span> S[N];	<span class="comment">// 前缀和数组</span></span><br><span class="line"><span class="keyword">int</span> l, r; 	<span class="comment">// 区间的左右坐标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// S[i] = a[1] + a[2] + ... a[i]</span></span><br><span class="line">S[i] = S[i<span class="number">-1</span>] + a[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//a[l] + ... + a[r] = S[r] - S[l - 1]</span></span><br><span class="line">sum = S[r] - S[l]	</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&amp;envId=top-100-liked">53.
最大子数组和 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&amp;envId=top-100-liked">560.
和为 K 的子数组 - 力扣（LeetCode）</a></p>
</blockquote>
<h3 id="二维前缀和">二维前缀和</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> S[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// S[i, j] = 第i行j列格子左上部分所有元素的和</span></span><br><span class="line">S[i][j] = S[i<span class="number">-1</span>][j] + S[i][j<span class="number">-1</span>] - S[i<span class="number">-1</span>][j<span class="number">-1</span>] + S[i][j];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span></span><br><span class="line"><span class="comment">// S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</span></span><br><span class="line">sum = S[x2][y2] - S[x2][y1<span class="number">-1</span>] - S[x1<span class="number">-1</span>][y2] + S[x1<span class="number">-1</span>][y1<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="一维差分">一维差分</h3>
<p>用于可以让一个序列中某个区间内的所有值均加上或减去一个常数。相当于a是差分数组的前缀和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[N];	<span class="comment">// 原数组 	下标从1开始，方便计算</span></span><br><span class="line"><span class="keyword">int</span> B[N];	<span class="comment">// 差分数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算差分</span></span><br><span class="line">B[i] = a[i] - a[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c</span></span><br><span class="line">B[l] += c; </span><br><span class="line">B[r + <span class="number">1</span>] -= c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还原数组</span></span><br><span class="line">a[i] = a[i<span class="number">-1</span>] + B[i];</span><br></pre></td></tr></table></figure>
<h3 id="二维差分">二维差分</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> B[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span></span><br><span class="line"><span class="comment">// S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    B[x1][y1] += c;</span><br><span class="line">    B[x2+<span class="number">1</span>][y1] -= c;</span><br><span class="line">    B[x1][y2+<span class="number">1</span>] -= c;</span><br><span class="line">    B[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建差分数组时使用 insert(i,j,i,j,a[i][j])</span></span><br><span class="line"><span class="comment">// 还原时要记住 a是B的前缀和数组</span></span><br><span class="line">a[i][j] = a[i<span class="number">-1</span>][j] + a[i][j<span class="number">-1</span>] - a[i<span class="number">-1</span>][j<span class="number">-1</span>] + B[i][j];</span><br></pre></td></tr></table></figure>
<h2 id="位运算">位运算</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">返回n的最后一位<span class="number">1</span>：<span class="built_in">lowbit</span>(n) = n &amp; -n</span><br></pre></td></tr></table></figure>
<h2 id="双指针问题">双指针问题</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 具体逻辑</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">不一定i, j都从一个方向走，可以双向奔赴♥！</span></span><br><span class="line"><span class="comment">常见问题分类：</span></span><br><span class="line"><span class="comment">    (1) 对于一个序列，用两个指针维护一段区间</span></span><br><span class="line"><span class="comment">    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.acwing.com/problem/content/801/">799.
最长连续不重复子序列 - AcWing题库</a></p>
<p><a href="https://www.acwing.com/problem/content/802/">800.
数组元素的目标和 - AcWing题库</a></p>
</blockquote>
<h2 id="离散化">离散化</h2>
<p>感觉使用map更加方便</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间合并">区间合并</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ======== by Xucong 贪心 ========</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Interval</span>&#123;</span>   <span class="comment">// 可以使用vector代替，sort比较vector的第一个元素</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Interval &amp; t)&#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; t.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Interval&gt; vec;</span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());  <span class="comment">// 按照左端点排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> right = vec[i].r;</span><br><span class="line">    <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;vec.<span class="built_in">size</span>() &amp;&amp; vec[j].l&lt;=right)&#123;</span><br><span class="line">        right = <span class="built_in">max</span>(vec[j].r, right);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体逻辑 [vec[i], .., vec[j]] 合并到一个区间</span></span><br><span class="line">    i = j<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.acwing.com/problem/content/805/">803. 区间合并 -
AcWing题库</a></p>
<p><a href="https://leetcode.cn/problems/merge-intervals/?envType=study-plan-v2&amp;envId=top-100-liked">56.
合并区间 - 力扣（LeetCode）</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树遍历</title>
    <url>/2021/10/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="二叉树遍历">二叉树遍历</h1>
<h2 id="概述">概述</h2>
<ul>
<li><p>二叉树是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。</p></li>
<li><p>二叉树是一种更为典型的树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。</p></li>
</ul>
<p>定义二叉树的节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x, TreeNode *left, TreeNode right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>常见的二叉树遍历方式有<strong>前序遍历、中序遍历、后序遍历、层序遍历</strong>。下面实现二叉树遍历的四种方式：</p>
<h2 id="遍历方式">遍历方式</h2>
<h3 id="前序遍历">前序遍历</h3>
<p>前序遍历的顺序是 <strong>根节点-&gt;左节点-&gt;右节点</strong></p>
<p>下列二叉树的前序遍历为： A B D E C F</p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209090012434.png" alt="image-20211009130611162">
<figcaption aria-hidden="true">image-20211009130611162</figcaption>
</figure>
<h4 id="递归实现">递归实现</h4>
<p>利用递归实现前序遍历十分简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="栈实现方法">栈实现方法</h4>
<p>利用栈实现前序遍历的核心是将树节点push到栈中然后在合适的时间从栈中弹出。</p>
<ul>
<li>首先将左节点push到栈中，push的同时访问当前节点数据。直到当前节点的左节点为nullptr。</li>
<li>判断栈是否为空，如果不为空就弹出当前栈顶节点，并push栈顶节点的右节点。</li>
<li>迭代上述操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; mySta;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !mySta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            mySta.<span class="built_in">push</span>(cur);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="comment">// mySta.push(cur);</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!mySta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cur = mySta.<span class="built_in">top</span>();</span><br><span class="line">            mySta.<span class="built_in">pop</span>();</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历">中序遍历</h3>
<p>中序遍历的顺序是 <strong>左节点-&gt;根节点-&gt;右节点</strong></p>
<p>下列二叉树的中序遍历为： D B E A F C</p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209090013617.png" alt="image-20211009135839077">
<figcaption aria-hidden="true">image-20211009135839077</figcaption>
</figure>
<h4 id="递归实现-1">递归实现</h4>
<p>利用递归实现中序遍历十分简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="栈实现方法-1">栈实现方法</h4>
<p>利用栈实现中序遍历的核心与前序遍历相同，只是需要注意访问节点数据的时机有所不同。</p>
<ul>
<li>首先将左节点push到栈中直到当前节点的左节点为nullptr。</li>
<li>判断栈是否为空，如果不为空就访问当前栈顶节点，并弹出当前栈顶节点，并push栈顶节点的右节点。</li>
<li>迭代上述操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; mySta;</span><br><span class="line">        <span class="comment">// mySta.push(root);</span></span><br><span class="line"></span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !mySta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                mySta.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!mySta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                cur = mySta.<span class="built_in">top</span>();</span><br><span class="line">                mySta.<span class="built_in">pop</span>();</span><br><span class="line">                ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历">后序遍历</h3>
<p>后序遍历的顺序是 <strong>左节点-&gt;右节点-&gt;根节点</strong></p>
<p>下列二叉树的后序遍历为： D E B F C A</p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209090014059.jpeg" alt="image-20211009140543901">
<figcaption aria-hidden="true">image-20211009140543901</figcaption>
</figure>
<h4 id="递归实现-2">递归实现</h4>
<p>利用递归实现前序遍历十分简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="栈实现方法-2">栈实现方法</h4>
<p>利用栈实现二叉树的后序遍历的核心与前序遍历相同。但需要注意的是，如果直接使用栈来实现后序遍历会相对比较麻烦，因为需要控制第二次访问根节点才能将栈顶元素弹出，从而需要一个额外的栈来实现节点的访问计数。因此我将讨论后序遍历与前序遍历之间的关系，来寻找更加简便的方法。</p>
<p>根据前面的讨论我们可以得知</p>
<ul>
<li><strong>前序遍历</strong>访问节点的顺序是
<strong>根节点-&gt;左节点-&gt;右节点</strong></li>
<li><strong>后序遍历</strong>访问节点的顺序是
<strong>左节点-&gt;右节点-&gt;根节点</strong></li>
</ul>
<p>假设我们将前序遍历的左右节点访问顺序交换，我们将会得到
<strong>根节点-&gt;右节点-&gt;左节点</strong> 的访问顺序。</p>
<p>接着将上述的顺序进行reverse。得到的顺序是
<strong>左节点-&gt;右节点-&gt;根节点</strong>
恰好和后序遍历的顺序相同。</p>
<p>因此我们只需要将前序遍历的栈实现方式中的所有<strong>左节点改为右节点</strong>，<strong>右节点改为左节点</strong>。同时在最后对结果进行<strong>reverse</strong>即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; mySta;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !mySta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            mySta.<span class="built_in">push</span>(cur);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="comment">// mySta.push(cur);</span></span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!mySta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cur = mySta.<span class="built_in">top</span>();</span><br><span class="line">            mySta.<span class="built_in">pop</span>();</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层序遍历">层序遍历</h3>
<p>层序遍历就是<strong>逐层遍历树结构</strong>。</p>
<p><strong>广度优先搜索</strong>是一种广泛运用在树或图这类数据结构中，遍历或搜索的算法。
该算法从一个根节点开始，首先访问节点本身。
然后遍历它的相邻节点，其次遍历它的二级邻节点、三级邻节点，以此类推。</p>
<p>当我们在树中进行广度优先搜索时，我们访问的节点的顺序是按照层序遍历顺序的。</p>
<p>下列二叉树的后序遍历为：A B C D E F</p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209090014780.png" alt="image-20211009142500875">
<figcaption aria-hidden="true">image-20211009142500875</figcaption>
</figure>
<h4 id="广度优先搜索实现">广度优先搜索实现</h4>
<p>广度优先搜索的核心是<strong>队列</strong>。将队首元素出队，如果该节点有子节点则将子节点入队。直到队首节点没有子节点，并且队列中没有节点时，遍历结束。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; myQueue;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    myQueue.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!myQueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = myQueue.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;cnt; i++)&#123;</span><br><span class="line">            TreeNode *cur = myQueue.<span class="built_in">front</span>();</span><br><span class="line">            myQueue.<span class="built_in">pop</span>();</span><br><span class="line">            temp.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                myQueue.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                myQueue.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索与图论</title>
    <url>/2024/07/30/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="搜索与图论">搜索与图论</h1>
<h2 id="树和图的存储">树和图的存储</h2>
<p>树是一种特殊的图，与图的存储方式相同。
对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。
因此我们可以只考虑有向图的存储。</p>
<ol type="1">
<li><p>邻接矩阵：g[a][b] 存储边a-&gt;b</p></li>
<li><p>邻接表 (前向星)：</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, ne, w;</span><br><span class="line">    </span><br><span class="line">&#125;node[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边 a -w-&gt; b</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    node[idx].to = b;</span><br><span class="line">    node[idx].ne = head[a];</span><br><span class="line">    node[idx].w = w;</span><br><span class="line">    head[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br></pre></td></tr></table></figure>
<h2 id="树与图的遍历">树与图的遍历</h2>
<p>时间复杂度 O(n+m) n 表示点数， m表示边数</p>
<h3 id="深度优先遍历">深度优先遍历</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> vis[N]; <span class="comment">// 存储访问情况</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    vis[root] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[root]; i!=<span class="number">-1</span>; i = node[i].ne)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = node[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 具体逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="广度优先搜索">广度优先搜索</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">vis[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (que.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i != <span class="number">-1</span>; i = node[i].ne)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = node[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!vis[j])&#123;</span><br><span class="line">            vis[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            que.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓扑排序">拓扑排序</h3>
<p>时间复杂度 O(n+m), n表示点数，m表示边数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="comment">// d[i] 存储节点i的入度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n; i++) </span><br><span class="line">    <span class="keyword">if</span>(d[i] == <span class="number">0</span>) que.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[cur]; i != <span class="number">-1</span>; i = node[i].ne)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = node[i].to;</span><br><span class="line">        <span class="keyword">if</span>(-- d[j] == <span class="number">0</span>) que.<span class="built_in">push</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路径">最短路径</h2>
<h3 id="dijkstra求最短路径">Dijkstra求最短路径</h3>
<p>单源最短路径</p>
<p>时间复杂度 O(mlogn)，n点数，m边数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, ne, w;</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="keyword">int</span> head[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示距离以及是否确定最短距离</span></span><br><span class="line"><span class="keyword">int</span> dis[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[a] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, a&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> cur = t.second;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(vis[cur]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[cur] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[cur]; i!=<span class="number">-1</span>; i=node[i].ne)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = node[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[j] &gt; dis[cur] + node[i].w)&#123;</span><br><span class="line">                dis[j] = dis[cur] + node[i].w;</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dis[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dis[b] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dis[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="bellman-ford算法">Bellman-Ford算法</h3>
<p>时间复杂度 O(nm), n表示点数，m表示边数</p>
<h3 id="spfa-算法队列优化的bellman-ford算法">Spfa
算法（队列优化的Bellman-Ford算法）</h3>
<p>时间复杂度 平均情况下 O(m)，最坏情况下 O(nm),
n表示点数，m表示边数</p>
<h3 id="spfa判断图中是否存在负环">Spfa判断图中是否存在负环</h3>
<p>时间复杂度是 O(nm), n表示点数，m表示边数</p>
<h3 id="floyd算法">Floyd算法</h3>
<p>多元最短路径</p>
<p>时间复杂度是 O(n3), n表示点数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化邻接矩阵每条边权为无穷大</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树">最小生成树</h2>
<h3 id="prim算法">Prim算法</h3>
<p>最小生成树，类似Dijkstra算法</p>
<p>堆优化版本，时间复杂度是 O(mlogn)，n表示点数，m 表示边数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.. 前向星 node[M], head[N], idx;</span></span><br><span class="line"><span class="keyword">int</span> dis[N], vis[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;pll, vector&lt;pll&gt;, greater&lt;pll&gt;&gt; heap;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!heap.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> distance = cur.first, a = cur.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[a]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[a] = <span class="number">1</span>;</span><br><span class="line">        sum += distance; cnt++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[a]; i!=<span class="number">-1</span>; i = node[i].ne)&#123;</span><br><span class="line">            <span class="keyword">int</span> b = node[i].to;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!vis[b] &amp;&amp; dis[b] &gt; node[i].w)&#123;</span><br><span class="line">                dis[b] = node[i].w;</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dis[b], b&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cnt != n) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="kruskal算法">Kruskal算法</h3>
<p>时间复杂度是 O(mlogm), n表示点数，m表示边数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="keyword">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span>     <span class="comment">// 存储边</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge &amp;e) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; e.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;     <span class="comment">// 并查集核心操作</span></span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )&#123;</span><br><span class="line">        <span class="keyword">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)&#123;     <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二分图">二分图</h2>
<h3 id="染色法">染色法</h3>
<h3 id="匈牙利算法">匈牙利算法</h3>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>链式前向星</tag>
        <tag>最小生成树</tag>
        <tag>最短距离</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2024/07/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="数据结构">数据结构</h1>
<h2 id="单调栈monotone-stack">单调栈（Monotone Stack）</h2>
<p>常见模型：找出每个数左边离它最近的比它大/小的数</p>
<h3 id="单调递增栈">单调递增栈</h3>
<p>保证栈内元素单调递增。（从栈顶到栈底）</p>
<ul>
<li>只有比栈顶大的元素才能直接进栈</li>
<li>首先先将栈中比当前元素大的元素出栈
<ul>
<li>出栈时，<strong>新元素</strong>是<strong>出栈元素</strong>向后找第一个比其小的元素</li>
<li>所有出栈后，<strong>栈顶元素</strong>是<strong>新元素</strong>向前找第一个比其小的元素</li>
</ul></li>
<li>再将当前元素出栈</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">	<span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; st.top &gt;= nums[i])&#123; <span class="comment">// 判断栈顶是否符合单调递增关系</span></span><br><span class="line">        <span class="comment">// 新元素是出栈元素向后找第一个比其小的元素</span></span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 栈顶元素是新元素向前找第一个比其小的元素</span></span><br><span class="line">    st.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体逻辑.. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.acwing.com/problem/content/832/">830. 单调栈 -
AcWing题库</a></p>
</blockquote>
<h3 id="单调递减栈">单调递减栈</h3>
<p>栈内元素递减</p>
<p>（同上）</p>
<h2 id="单调队列">单调队列</h2>
<p>常见模型：找出滑动窗口中的最大值/最小值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">deque&lt;Node&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">check_head</span>(que.<span class="built_in">front</span>())) que.<span class="built_in">pop_front</span>(); <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">check</span>(que.<span class="built_in">back</span>(), i)) que.<span class="built_in">pop_back</span>();   <span class="comment">// 判断队尾是否符合单调</span></span><br><span class="line">    que.<span class="built_in">push_back</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.acwing.com/problem/content/156/">154. 滑动窗口 -
AcWing题库</a></p>
</blockquote>
<h2 id="并查集">并查集</h2>
<h3 id="朴素并查集">朴素并查集</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure>
<h3 id="维护size的并查集">维护Size的并查集</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"><span class="keyword">int</span> p[N], size[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)];</span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure>
<h3 id="维护到祖宗节点距离的并查集">维护到祖宗节点距离的并查集</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p[N], d[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br></pre></td></tr></table></figure>
<h2 id="kmp-字符串匹配">KMP 字符串匹配</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line">求模式串的Next数组：</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="trie树">Trie树</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>指针形式</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isend;</span><br><span class="line">    TrieNode* child[<span class="number">26</span>];</span><br><span class="line">&#125;;</span><br><span class="line">TrieNode *root;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Trie</span>() &#123;</span><br><span class="line">    root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = word.<span class="built_in">size</span>();</span><br><span class="line">    TrieNode* cur = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;child[u]) cur-&gt;child[u] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        cur = cur-&gt;child[u];</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;isend = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = word.<span class="built_in">size</span>();</span><br><span class="line">    TrieNode* cur = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;child[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        cur = cur-&gt;child[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur-&gt;isend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>历史散文、诗人</title>
    <url>/2021/10/04/%E5%8E%86%E5%8F%B2%E6%95%A3%E6%96%87%E3%80%81%E8%AF%97%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="历史散文诗人">历史散文、诗人</h1>
<h2 id="历史散文">历史散文</h2>
<p><strong>《左传》：</strong>我国第一部叙事详细 形式完备的编年体史书。
（左丘明著）</p>
<p><strong>《春秋》：</strong>我国第一部编年体历史著作 （比左传早）</p>
<p><strong>《尚书》：</strong>我国第一部历史散文著作</p>
<p><strong>《国语》：</strong>我国第一部国别体史书。 （左丘明著）</p>
<p><strong>《战国策》：</strong>我国第一部国别体杂史。 （刘向著）</p>
<h2 id="屈原">屈原</h2>
<ul>
<li><p>字原、名平。自称云名正则，字灵均。</p></li>
<li><p>楚辞体的创始人。</p></li>
<li><p>是我国第一个爱国主义诗人、我国第一个浪漫主义诗人。</p></li>
<li><p>是我国浪漫主义文学奠基人，开辟了“香草美人”的传统。</p></li>
<li><p>被称为辞赋之祖、中华诗祖。</p></li>
</ul>
<p><strong>代表作：</strong>《九章》、《九歌》、《天问》、《离骚》。</p>
<ul>
<li><p>《楚辞》是我国第一部浪漫主义诗歌总集，是我国浪漫主义文学源头。（不是屈原一人写）</p></li>
<li><p>《离骚》和《国风》并称风骚。</p></li>
<li><p>《离骚》是我国诗歌中最长的浪漫主义政治抒情诗！</p></li>
</ul>
<h2 id="西汉">西汉</h2>
<ul>
<li><p>诗歌分为 汉乐府（五言为主）</p></li>
<li><p>《古诗十九首》为五言古诗体
被称为“一字千金”和“五言之冠冕”</p></li>
</ul>
<p><strong>汉乐府：</strong>汉代乐府机关</p>
<p><strong>汉乐府特色：</strong>以五言及杂言为主，口语化，题材叙事性，继承现代主义传统</p>
<p><strong>汉代四大家：</strong>司马相如、杨雄、班固、张衡。</p>
<p><strong>史书（司马光）：</strong>我国第一部纪传体通史。</p>
<ul>
<li>史书分为本纪 30世家、70列传、10表8书</li>
</ul>
<p><strong>汉书（班固）：</strong>我国第一部纪传体断代史。</p>
<p><strong>陌上桑语言特点：</strong>幽默诙谐，具有喜剧色彩，口语化，铺陈直叙的手法夸赞罗敷。</p>
<h2 id="李斯秦代">李斯（秦代）</h2>
<ul>
<li><p>法家学派</p></li>
<li><p>被称为 "秦朝文学一枝独秀”。</p></li>
<li><p>谏逐客书选自《史书 李斯列传》 （是奏章体政论文/议论文）</p></li>
</ul>
<p><strong>四君：</strong>秦穆公、秦孝公、秦惠公、秦昭王。</p>
<p><strong>期：</strong>服丧一年 大功：服丧九个月 小功：服丧五个月</p>
<h2 id="陶渊明">陶渊明</h2>
<ul>
<li><p>名潜、字元亮/渊明。私益号：靖节先生。自号：五柳先生。</p></li>
<li><p>田园诗创始人。</p></li>
<li><p>是我国最早大量创造田园诗的诗人。</p></li>
</ul>
<p><strong>称号：</strong>古今隐逸之宗/百世田园之主/千古隐逸之宗</p>
<p><strong>诗歌思想：</strong>厌倦官场、崇尚自然。</p>
<p><strong>诗歌风格：</strong>质朴自然、冲淡和平。</p>
<p><strong>诗歌特色：</strong>语言自然、朴素率真、善用白描、写意勾勒。</p>
<p><strong>文体：</strong>五言古体诗。</p>
<p><strong>题材：</strong>田园诗。</p>
<p><strong>作品集：</strong>《陶渊明集》</p>
<p><strong>代表作：</strong>《归园田居》、《桃花源记》、《归去来兮辞》</p>
<p><strong>山水诗开创者：</strong>谢灵运（谢康乐、大谢）、
谢朓（小谢）</p>
<ul>
<li>王国维在《人间词话》中说“无我之境，以物观物，故不知何者为我，何者为能”充分体现陶渊明《饮酒》诗歌的精神内涵</li>
</ul>
<h2 id="张若虚初唐后期">张若虚（初唐后期）</h2>
<ul>
<li><p>“吴中四士”之一（张若虚、贺知章、包融、张旭）</p></li>
<li><p>张若虚现存诗歌：《代答闺梦还》、《春江花月夜》</p></li>
<li><p>文体：古乐府诗/旧题、七言古诗、长篇歌行体。</p></li>
<li><p>长篇歌行体 是鲍照创照（题目中有歌、行、谣、引 的乐府诗）</p></li>
<li><p>闻一多代表作：《死水》《红烛》</p></li>
<li><p>评价《春江花月夜》是“诗中的诗，顶峰中的顶峰”“孤篇压全答”“孤篇横绝，竞为大家”“圣唐/唐代第一诗”</p></li>
</ul>
<h2 id="李白圣唐">李白（圣唐）</h2>
<ul>
<li><p>字太白、号青莲居士。诗仙，谪仙人。</p></li>
<li><p>浪漫主义诗人 。</p></li>
<li><p>诗歌：歌颂祖国大好河山，表现理想与现实的矛盾，风格豪放飘逸。</p></li>
<li><p>“唐代最伟大的诗人之一”</p></li>
</ul>
<p><strong>作品：</strong>《李太白集》</p>
<p><strong>古诗体：</strong>蜀道难、将进酒、梦游天老吟留别（楚词体）</p>
<p>​ 宣州谢脁楼饯别校书叔云</p>
<p><strong>《行路难》文体：</strong>乐府古诗、歌行体、七言古诗。选自《李白集校注》</p>
<h2 id="王伟盛唐">王伟（盛唐）</h2>
<ul>
<li><p>字摩诘（诗佛）</p></li>
<li><p>盛唐时期，山水田园诗派（描写自然风光，农村景象以及安逸恬淡的隐居生活，多用白描）</p></li>
<li><p>代表诗人：王维、孟浩然</p></li>
<li><p>被称为“天下之宗”。</p></li>
</ul>
<p><strong>作品集：</strong>《王右丞集》</p>
<p>苏轼评价王维诗歌：诗中有画，画中有诗</p>
<p>开创水墨山水画派</p>
]]></content>
      <categories>
        <category>Hsy</category>
      </categories>
      <tags>
        <tag>语文</tag>
      </tags>
  </entry>
  <entry>
    <title>MLP手写数字识别</title>
    <url>/2022/09/10/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="mlp手写数字识别">MLP手写数字识别</h1>
<blockquote>
<p>github项目：https://github.com/xclovehsy/digitalRecANNs</p>
</blockquote>
<h2 id="项目简介">项目简介</h2>
<p>构建一个神经网络，利用梯度下降法实现参数的更新，最终实现对0-9的10个手写数字的识别。</p>
<p>其中，MNIST 数据集在 http://yann.lecun.com/exdb/mnist/ 获取,
它包含了四个部分:</p>
<ul>
<li>Training set images: train-images-idx3-ubyte.gz (9.9 MB, 解压后 47
MB, 包含 60,000 个样本)</li>
<li>Training set labels: train-labels-idx1-ubyte.gz (29 KB, 解压后 60
KB, 包含 60,000 个标签)</li>
<li>Test set images: t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB,
包含 10,000 个样本)</li>
<li>Test set labels: t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含
10,000 个标签)</li>
</ul>
<h2 id="算法思路">算法思路</h2>
<h3 id="数据预处理">数据预处理</h3>
<p>MNIST手写数字图片集为60000条训练数据以及10000条测试数据。每一条为785个数字。每一条数据的第一个为数字的正确值，接下来的784个为图片的像素点，可以组成一篇28×28的像素的图片。数据预处理为纵向的784个数字矩阵，标签为纵向的10个数字，该每个数值介于0.01到0.99代表了识别为对应数字的概率。</p>
<h3 id="模型架构">模型架构</h3>
<p>这里我采用三层的神经网络模型，即一个输入层、一个隐藏层、一个输出层。</p>
<h3 id="参数说明">参数说明</h3>
<ul>
<li>Rate为神经网络模型梯度下降算法的学习率</li>
<li>epochs为神经网络模型训练的次数</li>
<li>input_num为神经网络模型的输入层节点数量即784个图片像素</li>
<li>hide_num为隐藏层节点数量</li>
<li>output_num为输出层节点数量</li>
<li>激活函数选用scipy中的expit函数</li>
</ul>
<h3 id="函数定义">函数定义</h3>
<p>这里的神经网络模型主要有两个函数，一个训练函数net_train以及一个识别函数net_query。</p>
<ul>
<li><p>net_train训练函数通过传入的手写数字图片数据对神经网络模型进行训练，利用梯度下降算法对权重矩阵进行更新。识别函数通过图片数据以及神经网络模型进行计算的到对应数字的识别匹配概率。</p></li>
<li><p>load_mnist函数负责加载MNIST数据集中的数据，show_result函数随机获取测试集中的部分数字对神经网络模型的识别结果进行展示。</p></li>
</ul>
<h2 id="结果分析">结果分析</h2>
<h3 id="实验结果">实验结果</h3>
<p>当将神经网络训练次数设置为10时，训练测试神经网络模型结果如下，并给出测试集中随机20张手写数值识别结果如下；</p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209072154162.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209072154171.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="结果分析-1">结果分析</h3>
<p>从实验结果可以看到，神经网络模型的正确识别率很高，在经过60000条数据训练后，识别的成功率高达95%以上。</p>
<p>将模型训练次数设置为1、5、10对神经网络模型进行训练并测试，可以看到当训练次数设置为1时，模型正确识别率为95.57%；当训练次数为5时，模型的正确识别率为97.23%；当训练次数设置为10时，模型的正确识别率为97.23%。</p>
<p>可以发现，模型识别的正确率随着模型训练次数的增加，在一定范围内增加。但是当超过一定的训练次数后，模型的识别正确率不会再增加，这有可能受限于神经网络的层数、隐藏层节点数量，以及手写数字图片的像素精度等因素。</p>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>mlp</tag>
      </tags>
  </entry>
  <entry>
    <title>Java文件管理器</title>
    <url>/2022/09/11/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="java文件管理器">Java文件管理器</h1>
<blockquote>
<p>github项目：https://github.com/xclovehsy/fileManage</p>
</blockquote>
<h2 id="简介">1. 简介</h2>
<h3 id="项目需求">1.1. 项目需求</h3>
<p>运用面向对象程序设计思想，基于Java文件管理和I/O框架，实现基于图形界面的GUI文件管理器。</p>
<h3 id="实现功能">1.2. 实现功能</h3>
<ol type="1">
<li>实现文件夹创建、删除、进入。</li>
<li>实现当前文件夹下的内容罗列。</li>
<li>实现文件拷贝和文件夹拷贝（文件夹拷贝指深度拷贝，包括所有子目录和文件）。</li>
<li>实现指定文件的加密和解密。</li>
<li>实现指定文件和文件夹的压缩。</li>
<li>实现压缩文件的解压。</li>
<li>文件管理器具有图形界面。</li>
</ol>
<h3 id="开发平台">1.3. 开发平台</h3>
<p><strong>开发语言：</strong> Java</p>
<p><strong>开发平台：</strong> Intellij IDEA 2021.2.2</p>
<h2 id="项目设计">2. 项目设计</h2>
<h3 id="mvc设计流程">2.1. MVC设计流程：</h3>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021611627.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol type="1">
<li>MainFrame作为整个程序的主体，向用户展示GUI界面，同时接受用户的操作。通过响应事件调用FileManager中的文件操作方法，并从FileController中获取当前文件路径对GUI界面进行更新。</li>
<li>FileManager作为文件操作的主要对象，通过调用各种方法对文件进行操作，例如文件创建、删除、加密、解密等。</li>
<li>FileController中保存了文件管理器的当前节点信息以及各种设置信息，以提供MainFrame进行界面的更新。</li>
</ol>
<h3 id="程序架构设计">2.2. 程序架构设计</h3>
<h4 id="整体结构框架">2.2.1. 整体结构框架</h4>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021612017.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<hr>
<h4 id="view结构">2.2.2. View结构</h4>
<ol type="1">
<li>MyTable中包含了自己定义JTree中的部分构件；</li>
<li>MyTree中包含了自己定义的JTable中的部分构件；</li>
<li>MainFrame则为主界面使得程序具有图形界面，主界面分成了几个Panel和一个Menubar。其中ChangePositionPan负责文件管理器上方文本区域，以及跳转到对应文件夹或打开文件功能；</li>
<li>MyMenubar负责菜单栏的显示以及对应按钮的响应事件；</li>
<li>ReturnPanel中包含了两个按钮负责返回上一级界面以及磁盘界面；</li>
<li>TableScrollPanel通过JTable展示文件信息（名称、修改事件、类型、大小等）；</li>
<li>TreeScrollPanel通过JTree展示文件管理器的文件存储结构，并通过点击文件夹节点，使ManFrame界面跳转的对应的文件夹界面。</li>
</ol>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021612021.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>对于Tree包，MyJTree负责显示目录树，MyJTreeNode负责构建目录树的结点并实现结点间的操作，而MyJTreeRender负责对目录树结点的图标渲染。</p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021612029.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>对于Table包，
MyJtableModel负责对数据进行整理，MyJTableCellRender负责对文件图标的渲染</p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021612034.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<hr>
<h4 id="fileoperation结构">2.2.3. FileOperation结构</h4>
<p>这个包中的的程序主要负责对文件的操作，其中FileController中保存了文件管理器的当前节点信息以及各种设置信息，以提供MainFrame进行界面的更新；</p>
<ol type="1">
<li>FileManager作为文件操作的主要对象，集成所有的文件操作，例如文件夹创建、删除、文件拷贝和文件夹拷贝等；</li>
<li>MainFrime通过调用FileManager中的方法间接调用其他几个类；</li>
<li>FileIcon负责获取文件的图标；</li>
<li>FileZip负责文件以及文件夹的压缩和解压缩；FileEncrypt通过IO流实现简单的文件加密操作；</li>
</ol>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021613183.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="uml类图">2.3. UML类图</h3>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021615668.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="项目展示">3. 项目展示</h2>
<h3 id="主界面展示">3.1. 主界面展示</h3>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021624967.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="创建删除进入">3.2. 创建、删除、进入</h3>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021624582.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021625913.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021625247.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="隐藏文件">3.3. 隐藏文件</h3>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021625083.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="文件压缩">3.4. 文件压缩</h3>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021626015.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<hr>
<p>更多功能请查看说明文档</p>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>组合逻辑电路</title>
    <url>/2021/10/09/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="组合逻辑电路">组合逻辑电路</h1>
<h2 id="偶校验码生成器">1. 偶校验码生成器</h2>
<p><strong>设某数字系统的数据交换按半字节进行（传输数据为4位），同时保证数据交换的正确性，设计一个偶校验码生成器。</strong></p>
<p>通过查阅资料得知：奇偶校验码是一种增加二进制传输系统最小距离的简单和广泛采用的方法。是一种通过增加<strong>冗余位</strong>使得码字中"1"的个数恒为奇数或偶数的编码方法。</p>
<p>现在定义四位的数据输入（半字节）</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> [<span class="number">0</span>:<span class="number">3</span>]in;</span><br></pre></td></tr></table></figure>
<p>接着定义五位偶检验码的输出。其中前4位对应数据输入的4位信息元，最后为1位偶校验元</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">output</span> [<span class="number">0</span>:<span class="number">4</span>]out;</span><br></pre></td></tr></table></figure>
<p>五位偶检验码的前4位为对应4位数据数据，可以直接对应。通过计算可以推导出偶检验码的计算公式，偶检验码
r = a<sub>0</sub>⊕a<sub>1</sub>⊕a<sub>2</sub>⊕a<sub>3</sub> （奇检验码 r
=
a<sub>0</sub>⊕a<sub>1</sub>⊕a<sub>2</sub>⊕a<sub>3</sub>⊕1）,其中a<sub>i</sub>表示4位传输数据中对应的码元。在verilog中使用"^"表示异或运算。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">out[<span class="number">0</span>:<span class="number">3</span>] = in[<span class="number">0</span>:<span class="number">3</span>];   <span class="comment">//4位输出信息元对应4位传输数据</span></span><br><span class="line">out[<span class="number">4</span>] = in[<span class="number">0</span>]^in[<span class="number">1</span>]^in[<span class="number">2</span>]^in[<span class="number">3</span>];   <span class="comment">//偶校验元</span></span><br></pre></td></tr></table></figure>
<p>因此偶校验码生成器完整代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/100ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> pccg(in,out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> [<span class="number">0</span>:<span class="number">3</span>]in;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">0</span>:<span class="number">4</span>]out;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">assign</span> out[<span class="number">0</span>:<span class="number">3</span>] = in[<span class="number">0</span>:<span class="number">3</span>];   <span class="comment">//4位输出信息元对应4位传输数据</span></span><br><span class="line"><span class="keyword">assign</span> out[<span class="number">4</span>] = in[<span class="number">0</span>]^in[<span class="number">1</span>]^in[<span class="number">2</span>]^in[<span class="number">3</span>];   <span class="comment">//偶校验元</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><strong>vivado生成的电路图如下：</strong></p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209090016846.png" alt="image-20211007213847079">
<figcaption aria-hidden="true">image-20211007213847079</figcaption>
</figure>
<h2 id="命令启停器">2. 命令启停器</h2>
<p><strong>为computer
house中烧咖啡的机器老鼠设计一个命令启停器。</strong></p>
<p>首先我定义一个总控制位En表示网关命令是否有效（1表示网关命令的有效，0表示网关命令无效）</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> En;</span><br></pre></td></tr></table></figure>
<p>通过题目得知网关命令中如果同时出现矛盾的命令对（F与B、I与S、TUON与TUOF）话，表示网关命令的无效。因此En应该如下表示：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">En = ~(F*B + I*S + TUON*TUOF);</span><br></pre></td></tr></table></figure>
<p>在老鼠四个动作行为中。老鼠的前进（A动作）、老鼠的后退（C动作）由En、F、B来控制，对应的真值表为：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">En</th>
<th style="text-align: center;">F</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">A</th>
<th style="text-align: center;">C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p>其中x表示该位可以为“1”也可以为“0”。如果当F和B同时为1时，En为0。因此包含在第一中情况中。</p>
<p>写出对应的verilog语言为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">A = En*F</span><br><span class="line">C = En*B</span><br></pre></td></tr></table></figure>
<p>此外在老鼠四个动作行为中。咖啡的注入（D动作）、咖啡的停止注入（E动作）由En、I、S来控制，对应的真值表为：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">En</th>
<th style="text-align: center;">I</th>
<th style="text-align: center;">S</th>
<th style="text-align: center;">D</th>
<th style="text-align: center;">E</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p>写出对应的verilog语言为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">D = En*I</span><br><span class="line">E = En*S</span><br></pre></td></tr></table></figure>
<p>因此烧咖啡机器老鼠的命令启停器的完整代码为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/100ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> controller(F, B, I, S, TUON, TUOF, A, C, D, E);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> F, B, I, S, TUON, TUOF;</span><br><span class="line"><span class="keyword">output</span> A, C, D, E;</span><br><span class="line"><span class="keyword">wire</span> En;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> En = ~(F*B + I*S + TUON*TUOF);</span><br><span class="line"><span class="keyword">assign</span> A = En*F;</span><br><span class="line"><span class="keyword">assign</span> C = En*B;</span><br><span class="line"><span class="keyword">assign</span> D = En*I;</span><br><span class="line"><span class="keyword">assign</span> E = En*S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><strong>通过vivado综合生成的电路图如下：</strong></p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209090015765.png" alt="image-20211007225740825">
<figcaption aria-hidden="true">image-20211007225740825</figcaption>
</figure>
]]></content>
      <categories>
        <category>Homework</category>
      </categories>
      <tags>
        <tag>数字逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title>唐代诗人</title>
    <url>/2021/10/05/%E5%94%90%E4%BB%A3%E8%AF%97%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="唐代诗人">唐代诗人</h1>
<h2 id="诗种类">诗种类</h2>
<p><strong>古诗体：</strong></p>
<ul>
<li>没有严格的平仄、句数、字数、韵律要求。</li>
<li>以四言、五言、七言以及杂言为主。</li>
</ul>
<p><strong>近体诗（今体诗 格律诗）：</strong></p>
<ul>
<li>产生于隋唐，盛行于唐。</li>
<li>一种讲究平仄、对仗、押韵的诗歌体。</li>
<li>律诗和绝句的通称。</li>
</ul>
<p><strong>律诗：</strong></p>
<ul>
<li>四联（颔联首联颈联尾联）</li>
<li>颔联 颈联需要对仗、对偶。</li>
<li>严格的用韵要求</li>
</ul>
<p><strong>绝句：</strong>没有严格的用韵要求</p>
<h2 id="杜甫盛唐">杜甫（盛唐）</h2>
<ul>
<li><p>杜少凌，杜工部，诗圣，诗歌界的孔子。</p></li>
<li><p>现实主义诗人。</p></li>
<li><p>诗歌深刻的反映了唐朝由盛转衰过程中的社会风貌和时代苦难。</p></li>
<li><p>其诗被被称为诗史。</p></li>
</ul>
<p><strong>诗歌风格：</strong>沉郁顿挫</p>
<p><strong>作品集：</strong>《杜少凌集》，《杜工部集》。</p>
<p><strong>作品：</strong>三吏三别、《新安吏》、《石壕吏》、《潼关吏》、《新婚别》、《无家别》、《垂老别》。</p>
<ul>
<li><p>《春望》感时花溅泪，恨别鸟惊心。 双关、五言律诗</p></li>
<li><p>《登高》老来多病，孤苦无依。 七言律诗</p></li>
</ul>
<p><strong>边塞诗派：</strong>高适、王昌龄、岑参。</p>
<h2 id="高适">高适</h2>
<ul>
<li>子达夫</li>
</ul>
<p><strong>作品集：</strong>《高常侍集》</p>
<p><strong>作品：</strong>别董大、燕歌行。</p>
<h2 id="王昌龄">王昌龄</h2>
<ul>
<li>字少伯</li>
</ul>
<p><strong>世称：</strong>王江宁、王龙标</p>
<p>“七绝圣手”、“诗歌夫子 王江宁”</p>
<p><strong>作品集：</strong>《王江宁集》</p>
<h2 id="岑参岑家州">岑参（岑家州）</h2>
<p><strong>作品集：</strong>《岑家州集》</p>
<p><strong>作品：</strong>白雪歌送武判官归京</p>
<h2 id="白居易中唐">白居易（中唐）</h2>
<ul>
<li><p>字乐天、号乐山居士、香山居士、江州司马、醉吟先生。</p></li>
<li><p>诗魔、诗王。</p></li>
<li><p>现代主义诗人。</p></li>
</ul>
<p><strong>主张：</strong>文章合为时而著，歌诗合为时而作。</p>
<p><strong>诗歌风格：</strong>平易晓畅（通俗易懂）</p>
<p><strong>作品集：</strong>《白氏长庆集》 “现存诗歌为唐人之冠”</p>
<p><strong>作品：</strong>琵琶行、长恨歌、卖炭翁、忆江南。</p>
<p><strong>新乐府：</strong>以新题写时事，不在以乐为标准。
首创为杜甫，“元白”倡导。</p>
<h2 id="韩愈">韩愈</h2>
<ul>
<li><p>字退之，韩昌龄、韩文公。</p></li>
<li><p>崇尚秦汉散文、反对六朝骈俪文风。</p></li>
</ul>
<p><strong>古文运动：</strong>排斥道教、佛教、崇尚儒学。</p>
<p><strong>文学主张：</strong>言之有物、辞必己出、惟陈言之务去。
文道合一、文以顺从、文以载道。</p>
<p><strong>地位：</strong>唐宋散文八大家之一
、千古文章四大家之一<strong>（柳宗元、韩愈、苏轼、欧阳修）</strong></p>
<p><strong>作品集：</strong>《昌龄先生集》</p>
<h2 id="柳宗元">柳宗元</h2>
<ul>
<li>字子厚、柳河东。</li>
<li>唐宋八大家之一 千古文章四大家之一</li>
<li>永州八记之首——始得西山宴游记</li>
</ul>
<p><strong>主张：</strong>针砭时弊，反对宦官专权、割据。反映民生疾苦，主张人以明道。</p>
<p><strong>寓言三则：</strong>哀溺之序、黔之驴、蝜蝂传.</p>
<p><strong>作品集：</strong>《柳河东集》</p>
<h2 id="刘禹锡">刘禹锡</h2>
<ul>
<li><p>字梦得、刘宾客。</p></li>
<li><p>诗豪。 “刘白”——刘禹锡和白居易</p></li>
</ul>
<p><strong>风格：</strong>清新明朗</p>
<p>作品集：《刘宾客集》、《刘禹锡集》、《刘梦得集》</p>
<p><strong>作品：</strong>陋室铭 秋词 西山塞怀古</p>
<p>怀古或咏史诗都是用典和对比</p>
<h2 id="李商隐">李商隐</h2>
<ul>
<li><p>字义山、号玉溪生、樊南生。</p></li>
<li><p>“小李杜”——李商隐、杜牧。</p></li>
<li><p>无题诗的开创人</p></li>
</ul>
<p><strong>风格：</strong>婉转缠绵、缠绵悱恻</p>
<p><strong>作品诗：</strong>《李义山集》、《樊南文集》</p>
<h2 id="杜牧">杜牧</h2>
<ul>
<li>字牧之</li>
</ul>
<p><strong>作品集：</strong>《樊川文集》</p>
<p><strong>作品：</strong>清明、阿房宫赋、泊秦淮、赤壁。</p>
]]></content>
      <categories>
        <category>Hsy</category>
      </categories>
      <tags>
        <tag>语文</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网络白板</title>
    <url>/2022/09/10/%E7%BD%91%E7%BB%9C%E7%99%BD%E6%9D%BF%E7%9A%84java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="java网络白板">Java网络白板</h1>
<h1 id="网络白板">网络白板</h1>
<blockquote>
<p>github项目：https://github.com/xclovehsy/whiteBoard</p>
</blockquote>
<h2 id="简介">简介</h2>
<h3 id="项目需求">项目需求</h3>
<p>网络白板利用面相对象的思想设计适合可扩展的图形类集，利用java
gui的mvc模式设计用户的绘图流程，利用java的套接字编程实现多客户端的数据共享方法，利用多线程机制实现绘图和数据传输的并发控制机制</p>
<h3 id="实现功能">实现功能</h3>
<ol type="1">
<li>程序能够在窗体上根据用户的选择绘制不同形状（3个以上）的图形；</li>
<li>程序能够修改图形的属性（颜色和大小）和位置（利用鼠标移动选定的图形）；</li>
<li>网络客户端的程序能够协同绘图（一个用户绘图其他用户均可见绘图效果）；</li>
<li>程序能够以文件的形式保存绘图结果，下次启动程序后能够读取绘图结果文件再现绘图效果。</li>
</ol>
<p><strong>开发语言：</strong> Java</p>
<p><strong>开发平台：</strong> Intellij IDEA 2021.2.2</p>
<h2 id="项目设计">项目设计</h2>
<h3 id="mvc设计流程">MVC设计流程</h3>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061101956.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol type="1">
<li>GUIServer作为服务器接受客户端发送的图形数据，并将图形数据写入Data.txt文件中保存，同时将图形数据发送到各个客户端。</li>
<li>用户操作OpenGLApp画板。每画一个图形，程序会将数据发送到服务器。同时接受服务器传输的图形数据进行绘图。</li>
<li>Data.txt文件用于保存图形数据，每当服务器开启时将会读取文件中上次保存的图形数据，并发送到各个客户端进行绘图。</li>
</ol>
<h3 id="程序架构设计">程序架构设计</h3>
<h4 id="整体结构框架">整体结构框架</h4>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061101514.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>该程序代码共有三个部分</p>
<ol type="1">
<li>app为网络白板客户的主程序</li>
<li>graph为图形包，里面包含了各种图形的数据，例如圆形、立方体、长方形等等。</li>
<li>server负责服务器数据的接受与发送，以及数据的保存</li>
<li>Data.txt用于保存图形数据</li>
</ol>
<hr>
<h4 id="程序结构">程序结构</h4>
<p>OpenGLApp为网络白板客户端的主程序，负责GUI的显示，图形的绘制、发送数据、接受服务器发送的数据等，同时实现了1、根据用户的选择绘制不同形状（3个以上）的图形；2、修改图形的属性（颜色和大小）和位置（利用鼠标移动选定的图形）等功能。</p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061102231.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<hr>
<h4 id="graph结构">Graph结构</h4>
<ol type="1">
<li>Shape类是图形类的抽象父类,
它包含一个抽象方法draw(),在他的派生类中都实现了draw（）方法、各自的属性和属性的修改方法；</li>
<li>Graphic是用来存储当前已有的对象和绘制已有的对象；</li>
<li>Cube、Circle、Rectangle等均是Shape的子类。</li>
</ol>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061103998.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>Graph包类图如下（可见附件三）</strong></p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061104406.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<hr>
<h4 id="server结构">Server结构</h4>
<ol type="1">
<li>GUIServer为服务器端，接受客户端发送的图形数据，并将图形数据写入Data.txt文件中保存。</li>
<li>SeverThread多线程操作，可以并发的接受多个客户端的数据，并传送数据。</li>
</ol>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061105343.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="uml类图">UML类图</h3>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061105680.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="项目展示">项目展示</h2>
<h3 id="主界面">主界面</h3>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061106996.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="功能测试">功能测试</h3>
<h4 id="绘制图形">绘制图形</h4>
<p><strong>程序能够在窗体上根据用户的选择绘制不同形状（3个以上）的图形；</strong></p>
<p>该程序可以根据用户需要绘制不同的图形，通过点击面板上不同的图形按钮设置当前绘制的图形种类。例如圆形、椭圆、立方体、长方形、三角形等</p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061106005.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>#### 修改图形</p>
<p><strong>程序能够修改图形的属性（颜色和大小）和位置（利用鼠标移动选定的图形）；</strong></p>
<p>可以选择不同的线条颜色以及填充颜色</p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061106011.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h4 id="网络协同">网络协同</h4>
<p><strong>网络客户端的程序能够协同绘图（一个用户绘图其他用户均可见绘图效果）；</strong></p>
<p>打开sever.GUISever服务器程序，等待其他画板的连接</p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061107060.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>同时将网络白板客户端程序运行4次服务器连接上程序</p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061107064.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061107082.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>在客户端1绘制图形将会传输其他客户端白板中。</li>
<li>在一个客户端中对图形进行修改，其他客户端的图形也会修改。即网络客户端的程序能够协同绘图（一个用户绘图其他用户均可见绘图效果）；</li>
</ul>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061107093.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<hr>
<p><strong>更多功能请查看说明文档</strong></p>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>秦七子</title>
    <url>/2021/10/03/%E7%A7%A6%E4%B8%83%E5%AD%90/</url>
    <content><![CDATA[<h1 id="秦七子">秦七子</h1>
<p><strong>老庄孔墨孟荀韩非 子（无列子）</strong></p>
<h2 id="老子春秋末期">老子（春秋末期）</h2>
<ul>
<li><p>又称老聃，姓李、名耳、字伯阳。</p></li>
<li><p>道家学派创始人，与庄子合称为老庄。</p></li>
</ul>
<p><strong>核心思想：</strong>道法自然 贵柔守雌 无为而治 辩证法思想</p>
<p><strong>代表作：</strong>《老子》又称《道德经》万经之王 道德真经
德道经 五千言 老子五千文</p>
<p><strong>散文特点：</strong>具有深刻的哲理性和系统的思辨性</p>
<h2 id="庄子战国中期">庄子（战国中期）</h2>
<ul>
<li><p>名周，字子休/沐。</p></li>
<li><p>道家学派 和老子合称老庄。</p></li>
</ul>
<p><strong>思想核心：</strong>顺其自然，提倡无为而不为。</p>
<p><strong>代表作：</strong>《庄子》又称《南华经》</p>
<p><strong>散文特点：</strong>构思精巧、想象丰富、文笔恣肆、词藻瑰丽、</p>
<p>​ 采用寓言形式、善用连类比喻、富有浪漫色彩。</p>
<p><strong>“三玄”：</strong>《周易》《老子》《庄子》</p>
<p>秋水又名河泊与北海若</p>
<h2 id="孔子春秋末期">孔子（春秋末期）</h2>
<ul>
<li><p>字丘，名仲尼。</p></li>
<li><p>儒家学派创始人。</p></li>
<li><p>被称为“大成至圣，万世师表”，开创讲学风气。</p></li>
</ul>
<p><strong>思想核心：</strong>仁和礼（克己复礼）</p>
<ul>
<li><p>代表作《论语》是其孔子弟子和再传弟子的语录体散文集</p></li>
<li><p>《论语》是我国最早的语录体散文集</p></li>
</ul>
<p><strong>散文特点：</strong>通俗易懂 善用修辞 具有格言色彩</p>
<p><strong>最高理想：</strong>大同</p>
<p><strong>教育思想：</strong>有教无类 因材施教</p>
<h2 id="孟子战国中期">孟子(战国中期）</h2>
<ul>
<li>名轲，儒家学派，被称为亚圣。</li>
</ul>
<p><strong>思想核心：</strong>仁政和王道
主张名贵君轻的民本思想，反对暴政</p>
<p><strong>作品：</strong>《孟子》</p>
<ul>
<li>《孟子》是孟子与其弟子共同编写 是论说体 多选题中也是语录体</li>
</ul>
<p><strong>散文特点：</strong>欲擒故纵，引君入豰的论辩思想，采用各种比喻增强辩论的形象性和说服力，大量运用排偶</p>
<h2 id="荀子">荀子</h2>
<ul>
<li>名况，儒家学派。</li>
</ul>
<p><strong>核心思想：</strong>天行有常，人性本恶，重法爱民，隆礼敬士，人不可以已。</p>
<p><strong>代表作：</strong>《荀子》</p>
<h2 id="墨子">墨子</h2>
<ul>
<li><p>名翟</p></li>
<li><p>墨家代表</p></li>
</ul>
<p><strong>思想核心：</strong>兼爱 非攻 尚贤</p>
<p><strong>代表作：</strong>《墨子》</p>
<h2 id="韩非子">韩非子</h2>
<ul>
<li>法家创始人</li>
</ul>
<p><strong>思想核心：</strong>法术势</p>
<p><strong>代表作：</strong>《韩非子》</p>
]]></content>
      <categories>
        <category>Hsy</category>
      </categories>
      <tags>
        <tag>语文</tag>
      </tags>
  </entry>
  <entry>
    <title>旅行商问题</title>
    <url>/2022/09/09/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="旅行商问题">旅行商问题</h1>
<blockquote>
<p>github项目：https://github.com/xclovehsy/geneticAlgoTSP</p>
</blockquote>
<h2 id="项目描述">1. 项目描述</h2>
<p>一个旅行者需要到国内的10个城市旅行，各城市的坐标见cities.csv文档。请设计一个合理的线路使旅行者所行的路程之和最小。注意：每个城市只能访问一次，且最后要回到原来出来的城市。</p>
<h2 id="算法思路">2. 算法思路</h2>
<p><strong>遗传算法</strong>是一种模仿自然界生物进化机制的全局搜索和优化方法。其具有以下几个基本的特征，接下来是对各个特征详细的说明。</p>
<ul>
<li><p><strong>表现型：</strong>旅行依次经过的城市，即旅行的路径。例如“重庆—&gt;北京—&gt;上海—&gt;天津—&gt;成都—&gt;…
—&gt;重庆”这是一种旅行路径，这里需要注意的是最终需要回到起点。</p></li>
<li><p><strong>基因型：</strong>我根据cities.csv文件中的城市出现的顺序，对城市进行1.2.3….编码。然后旅行经过的城市依次以序号进行编码。同时因为最后要回到起点，因此起点和终点的序号应该相同。</p></li>
<li><p>这里我们根据cities.csv文件中城市的次序进行编码，即：北京-0、天津-1、上海-2、重庆-3、拉萨-4、乌鲁木齐-5、银川-6、呼和浩特-7、南宁-8、哈尔滨-9。</p></li>
<li><p><strong>编码：</strong>这里我选择的编码方式为：对城市进行1.2.3…次序编码，然后一条旅行路线为一个个体，编码方式为起点到终点依次经过城市的序号编码。</p></li>
<li><p><strong>进化：</strong>种群逐渐适应生存环境，即总的路径长度不断得到缩小。旅行线路的进化是以种群的形式进行的。</p></li>
<li><p><strong>适应度：</strong>度量某个旅行线路对于生存环境的适应程度。这里我使用旅行线路总的路径长度倒数作为种群的适应度</p></li>
<li><p><strong>选择：</strong>以一定的概率从种群中选择若干个个体。我使用轮盘赌的方式对种群中的个体进行选择。</p></li>
<li><p><strong>交叉：</strong>两个旅行线路的某一相同位置处城市编码，前后两串分别交叉组合形成两个新的旅行线路。也称基因重组或杂交；</p></li>
<li><p><strong>变异：</strong>以一定的概率对种群中的个体进行基因突变，即随机选择个体基因中两个城市的编号进行交换。</p></li>
</ul>
<h2 id="遗传算法步骤">3. 遗传算法步骤</h2>
<p>开始循环直至找到满意的解。</p>
<ol type="1">
<li>评估每条染色体所对应个体的适应度。</li>
<li>遵照适应度越高，选择概率越大的原则，从种群中选择两个个体作为父方和母方。</li>
<li>抽取父母双方的染色体，进行交叉，产生子代。</li>
<li>对子代的染色体进行变异。</li>
<li>重复2，3，4步骤，直到新种群的产生。</li>
</ol>
<p>结束循环。</p>
<p><strong>算法流程图：</strong></p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209072116751.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="程序代码">4. 程序代码</h2>
<p>这里一共有三个模块分别是Life.py、GA.py、TSP.py，每个模块的作用如下：</p>
<ul>
<li>Life.py为种群中的旅游线路个体类，里面包含旅行路线的基因型以及适应值</li>
<li>GA.py为遗传算法内，里面主要包含了遗传算法的一些函数，例如基因交叉、基因突变、轮盘赌选择个体、生成个体、生成新一代种群等函数。</li>
<li>TSP.py为旅行商问题的主要运行模块，包含对城市数据的读取，计算适应值、绘制适应度函数的进化曲线和最终选择的线路图等功能。</li>
</ul>
<p>具体代码请查看目录“lab3”</p>
<h2 id="运行结果">5. 运行结果</h2>
<p>这里设置一个种群中包含20个体，迭代200次后计算得出最优路径。gen表示迭代到第i代种群，dis表示该种群中最优个体的总旅行距离。</p>
<p><strong>运行结果如下：</strong></p>
<p>gen:1, dis:150.1067758288992</p>
<p>gen:2, dis:150.1067758288992</p>
<p>...</p>
<p>gen:199, dis:109.98824625831303</p>
<p>gen:200, dis:109.98824625831303</p>
<hr>
<p>经历过200次迭代后，最短路径为：</p>
<p>北京——&gt;呼和浩特, dis:4.8935</p>
<p>呼和浩特——&gt;银川, dis:5.8709</p>
<p>银川——&gt;乌鲁木齐, dis:19.0424</p>
<p>乌鲁木齐——&gt;拉萨, dis:14.1505</p>
<p>拉萨——&gt;重庆, dis:15.4347</p>
<p>重庆——&gt;南宁, dis:6.9833</p>
<p>南宁——&gt;上海, dis:15.5932</p>
<p>上海——&gt;哈尔滨, dis:15.4157</p>
<p>哈尔滨——&gt;天津, dis:11.5217</p>
<p>天津——&gt;北京, dis:1.0825</p>
<p>最短路径距离为：109.9882</p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209072119886.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>图2适应度函数的进化曲线</p>
<figure>
<img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209072119894.gif" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>图3最终选择的线路图</p>
<h2 id="结果分析">6. 结果分析</h2>
<p>由适应度函数的进化曲线可得知，刚开始种群进化速度很快，当适应值接近最优值时进化速度放缓。由图像可知在接近100代种群时适应值收敛。说明遗传的收敛效果良好。</p>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>遗传算法</tag>
      </tags>
  </entry>
  <entry>
    <title>诗经、楚辞</title>
    <url>/2021/10/04/%E8%AF%97%E7%BB%8F%E3%80%81%E6%A5%9A%E8%BE%9E/</url>
    <content><![CDATA[<h1 id="诗经楚辞">诗经、楚辞</h1>
<h2 id="诗经">诗经</h2>
<ul>
<li><p>《诗经》又称《诗》和《诗三百》</p></li>
<li><p>是我国第一部（最早）现实主义诗歌总集</p></li>
<li><p>记录了周初到周末500年历史</p></li>
<li><p>共305篇</p></li>
</ul>
<p><strong>诗经六义：</strong>风雅颂 赋比兴</p>
<p><strong>风（内容）</strong>：十五国风，共160篇。多用复沓手法，多为民歌。</p>
<p><strong>雅（题材）</strong>：《大雅》和《小雅》105篇
多为贵族宫廷乐曲。</p>
<p><strong>颂（音乐）</strong>：《周颂》、《商颂》、《鲁颂》</p>
<p><strong>赋</strong>：铺陈直叙。</p>
<p><strong>比</strong>：以彼物必此物。</p>
<p><strong>兴</strong>：借物比喻，触物兴词，以次及彼。</p>
<p><strong>《诗经》手法：</strong>重章叠句、情景交融、起兴手法、虚实结合。</p>
<p><strong>诗经艺术特色：</strong>以四言为主，重章叠句，节奏简约明快，情致回环往复
多用比兴手法，意蕴丰赡含蓄</p>
<ul>
<li><p>诗经中的国风被称为现代主义诗歌源头</p></li>
<li><p>王国维在《人间词话》评价蒹葭是“最得风人深致”</p></li>
</ul>
<h2 id="楚辞">楚辞</h2>
<ul>
<li><p>是楚地民歌或者歌辞</p></li>
<li><p>楚辞体是一种新诗体，一般采用四言或八言</p></li>
</ul>
]]></content>
      <categories>
        <category>Hsy</category>
      </categories>
      <tags>
        <tag>语文</tag>
      </tags>
  </entry>
</search>
