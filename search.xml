<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>UnitStudent 新生报道系统</title>
    <url>/2022/09/10/UnitStudent%20%E6%96%B0%E7%94%9F%E6%8A%A5%E9%81%93%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="UnitStudent-新生报道系统"><a href="#UnitStudent-新生报道系统" class="headerlink" title="UnitStudent 新生报道系统"></a>UnitStudent 新生报道系统</h1><p>2022-8-19 中软国际实训项目 </p>
<blockquote>
<p>github项目：<a href="https://github.com/xclovehsy/uniStudent">https://github.com/xclovehsy/uniStudent</a></p>
</blockquote>
<h2 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1. 项目简介"></a>1. 项目简介</h2><p><strong>软件名称：</strong><br>UnitStudent新生报道系统</p>
<p><strong>软件应用：</strong><br>该系统将主要面向重庆财经学院软件学院的2022级新生以及所有老师，使整个新生报道流程信息化，让新生和老师能够实时了解到新生报道的进行情况。<br>新生报道系统结合新生报到时的需求，利用网络的即时性，提高新生报到工作效率，减少报道所需，为报道的新生提供即时准确的报道相关信息，同时可以对自己的性格进行简单的测评，帮助新生进一步了解自己；<br>在帮助新生顺利完成报道的同时也为新生报到的规范化和信息化管理打坚实的基础。</p>
<h2 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2. 需求分析"></a>2. 需求分析</h2><p><strong>需求范围：</strong><br>重庆财经学院软件学院</p>
<p><strong>系统包括的功能范围：</strong></p>
<ol>
<li>学校功能</li>
<li>查看新生报道实时进展</li>
<li>查看新生相关信息（专业，性别，地区，年龄）</li>
<li>查看新生职业性格大体分布</li>
</ol>
<p><strong>新生功能：</strong></p>
<ol>
<li> 填写自身相关信息</li>
<li> 进行职业性格测试</li>
<li> 查看报道流程</li>
<li> 查看报道实时进展</li>
<li> 查看新生相关信息（专业，性别，地区，年龄）</li>
<li> 查看学校概况</li>
</ol>
<h2 id="3-运行环境"><a href="#3-运行环境" class="headerlink" title="3. 运行环境"></a>3. 运行环境</h2><p>本软件开发所使用的语言以及开发工具：</p>
<p>开发平台及工具；MySQL、Hbuilder X、Pycharm</p>
<p>通信协议：HTTP，TCP/IP</p>
<p>前端使用uniapp框架，后端使用python语言，fastapi进行接口的实现。</p>
<h2 id="4-项目预览"><a href="#4-项目预览" class="headerlink" title="4. 项目预览"></a>4. 项目预览</h2><h3 id="4-1-应用框架"><a href="#4-1-应用框架" class="headerlink" title="4.1. 应用框架"></a>4.1. 应用框架</h3><hr>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021443731.png" alt="image-20220902144331571"></p>
<h3 id="4-2-流程图"><a href="#4-2-流程图" class="headerlink" title="4.2. 流程图"></a>4.2. 流程图</h3><hr>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021444357.png" alt="image-20220902144458239"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021446848.png" alt="image-20220902144602780"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021453406.png" alt="image-20220902145359327"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021454389.png" alt="image-20220902145410313"></p>
<h3 id="4-3-项目界面"><a href="#4-3-项目界面" class="headerlink" title="4.3. 项目界面"></a>4.3. 项目界面</h3><h4 id="4-3-1-信息录入"><a href="#4-3-1-信息录入" class="headerlink" title="4.3.1. 信息录入"></a>4.3.1. 信息录入</h4><hr>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100813507.jpg" alt="Screenshot_20220909_212753_com.tencent.mm"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100822778.jpg"></p>
<h4 id="4-3-2-信息总览"><a href="#4-3-2-信息总览" class="headerlink" title="4.3.2. 信息总览"></a>4.3.2. 信息总览</h4><hr>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100812240.jpg" alt="Screenshot_20220909_212208_com.tencent.mm"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100812765.jpg" alt="Screenshot_20220909_212216_com.tencent.mm"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100812753.jpg" alt="Screenshot_20220909_212225_com.tencent.mm"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100813592.jpg" alt="Screenshot_20220909_212230_com.tencent.mm"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100813636.jpg" alt="Screenshot_20220909_212240_com.tencent.mm"></p>
<h4 id="4-3-3-数据面板"><a href="#4-3-3-数据面板" class="headerlink" title="4.3.3. 数据面板"></a>4.3.3. 数据面板</h4><hr>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100814029.jpg" alt="Screenshot_20220909_212823_com.tencent.mm"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100814845.jpg" alt="Screenshot_20220909_212828_com.tencent.mm"></p>
<h4 id="4-3-4-新生指南"><a href="#4-3-4-新生指南" class="headerlink" title="4.3.4. 新生指南"></a>4.3.4. 新生指南</h4><hr>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100813181.jpg" alt="Screenshot_20220909_212342_com.tencent.mm"></p>
<h4 id="4-3-5-性格测试"><a href="#4-3-5-性格测试" class="headerlink" title="4.3.5. 性格测试"></a>4.3.5. 性格测试</h4><hr>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100814203.jpg" alt="Screenshot_20220909_212354_com.tencent.mm"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100814152.jpg" alt="Screenshot_20220909_212613_com.tencent.mm"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100814481.jpg" alt="Screenshot_20220909_212627_com.tencent.mm"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100814850.jpg" alt="Screenshot_20220909_212642_com.tencent.mm"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209100814057.jpg" alt="Screenshot_20220909_212702_com.tencent.mm"></p>
<h4 id="4-3-6-大数据面板"><a href="#4-3-6-大数据面板" class="headerlink" title="4.3.6. 大数据面板"></a>4.3.6. 大数据面板</h4><hr>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021514993.jpg" alt="image-20220902150435623"></p>
<h2 id="5-程序入口"><a href="#5-程序入口" class="headerlink" title="5. 程序入口"></a>5. 程序入口</h2><p><strong>程序入口二维码：</strong></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209102321648.jpg" alt="-170c280b23612a5c"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209102321486.jpg" alt="-1bf9d8e9c0a82e3"></p>
<blockquote>
<p>大数据面板：<a href="http://v.yuntus.com/tcv/0590A5ac63f90BA555CE76d4686F0772">http://v.yuntus.com/tcv/0590A5ac63f90BA555CE76d4686F0772</a></p>
</blockquote>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>uniapp</tag>
      </tags>
  </entry>
  <entry>
    <title>git的基本使用</title>
    <url>/2022/09/09/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="git的基本使用"><a href="#git的基本使用" class="headerlink" title="git的基本使用"></a>git的基本使用</h1><h2 id="1-仓库管理"><a href="#1-仓库管理" class="headerlink" title="1. 仓库管理"></a>1. 仓库管理</h2><ol>
<li><p>初始化仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li>
<li><p>添加/删除文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add/rm [filename]</span><br><span class="line">git add . # 添加所有文件</span><br></pre></td></tr></table></figure></li>
<li><p>提交代码到本地仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;commit file</span><br></pre></td></tr></table></figure></li>
<li><p>查看仓库状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li>
<li><p>添加远程仓库url</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin [repository url]</span><br></pre></td></tr></table></figure></li>
<li><p>同步本地仓库代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></li>
<li><p>上传代码到远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一次提交</span><br><span class="line"># 将本地的master分支和远程仓库origin的master分支关联</span><br><span class="line">git push -u origin master   </span><br><span class="line"></span><br><span class="line"># 经常使用</span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"># 强行提交，谨慎使用 </span><br><span class="line"># f表示force</span><br><span class="line">git push origin master -f </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-分支管理"><a href="#2-分支管理" class="headerlink" title="2. 分支管理"></a>2. 分支管理</h2><h3 id="2-1-本地操作"><a href="#2-1-本地操作" class="headerlink" title="2.1. 本地操作"></a>2.1. 本地操作</h3><ol>
<li><p>查看分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line"></span><br><span class="line"># 查看所用分支，以及其关联的远程分支</span><br><span class="line">git branch -a</span><br></pre></td></tr></table></figure></li>
<li><p>创建分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch [branch name]</span><br></pre></td></tr></table></figure></li>
<li><p>切换分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout [branch name]</span><br></pre></td></tr></table></figure></li>
<li><p>分支快速创建和切换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b [branch name]</span><br></pre></td></tr></table></figure></li>
<li><p>分支合并</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 首先需要切换到合并的主分支上去</span><br><span class="line">git merge [branch name]</span><br></pre></td></tr></table></figure>

<p><strong>遇到冲突时的分支合并</strong><br>如果在两个不同的分支中，对同一个文件进行了不同的修改，Git 就没法干净的合并它们。 此时，我们需要打开这些包含冲突的文件然后手动解决冲突。</p>
</li>
<li><p>删除分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d [branch name]</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-2-远程操作"><a href="#2-2-远程操作" class="headerlink" title="2.2. 远程操作"></a>2.2. 远程操作</h3><ol>
<li><p>查看远程仓库分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote show [repository name]</span><br></pre></td></tr></table></figure></li>
<li><p>本地分支推送到远程仓库分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -u 表示把本地分支和远程分支进行关联，只在第一次推送的时候需要带 -u 参数</span><br><span class="line">git push -u 远程仓库的别名 本地分支名称: 远程分支名称</span><br><span class="line"></span><br><span class="line"># 案例</span><br><span class="line">git push -u origin payment:pay</span><br><span class="line"></span><br><span class="line"># 如果希望远程分支的名称和本地分支名称保持一直，可以对命令进行简化：</span><br><span class="line">git push -u origin payment</span><br></pre></td></tr></table></figure></li>
<li><p>跟踪分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从远程仓库中，把对应的远程分支下载到本地仓库，名字保持一致</span><br><span class="line">git checkout 远程分支的名称</span><br><span class="line"></span><br><span class="line"># 从远程仓库中，把对应的远程分支下载到本地仓库，并把下载的本地分支进行重命名</span><br><span class="line">git checkout -b 本地分支名称 远程仓库名称/远程分支名称</span><br><span class="line"></span><br><span class="line"># 案例  把远程仓库origin里面的pay分支下载并重命名为payment分支</span><br><span class="line">git checkout -b payment origin/pay</span><br></pre></td></tr></table></figure></li>
<li><p>拉取远程分支最新代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></li>
<li><p>删除远程分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin --delete [branch name]</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>卓越工程师</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客搭建</title>
    <url>/2022/09/08/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="1-推送博客文件"><a href="#1-推送博客文件" class="headerlink" title="1. 推送博客文件"></a>1. 推送博客文件</h2><ol>
<li><p>清空之前的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></li>
<li><p>生成静态文章</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"># 简写</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure></li>
<li><p>部署博客</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy </span><br><span class="line"></span><br><span class="line"># 简写 </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-本地测试"><a href="#2-本地测试" class="headerlink" title="2. 本地测试"></a>2. 本地测试</h2><ol>
<li><p>生成静态文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></li>
<li><p>打开本地服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-写文章"><a href="#3-写文章" class="headerlink" title="3. 写文章"></a>3. 写文章</h2><ol>
<li><p>新建文章</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;title&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>新建草稿文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new draft &quot;title&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>新建界面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;title&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>卓越工程师</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用指令</title>
    <url>/2022/09/09/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Linux常用指令"><a href="#Linux常用指令" class="headerlink" title="Linux常用指令"></a>Linux常用指令</h1><h2 id="1-档案与目录管理"><a href="#1-档案与目录管理" class="headerlink" title="1. 档案与目录管理"></a>1. 档案与目录管理</h2><h3 id="1-1-切换路径"><a href="#1-1-切换路径" class="headerlink" title="1.1. 切换路径"></a>1.1. 切换路径</h3><ol>
<li><p>绝对路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 绝对路径，路径前+“/” 表示绝对路径</span><br><span class="line">cd /home/xc  </span><br></pre></td></tr></table></figure></li>
<li><p>相对路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd test </span><br></pre></td></tr></table></figure></li>
<li><p>显示当前路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure></li>
<li><p>清空终端信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-2-显示文件列表"><a href="#1-2-显示文件列表" class="headerlink" title="1.2. 显示文件列表"></a>1.2. 显示文件列表</h3><ol>
<li><p>当前目录下的文件、目录名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure></li>
<li><p>文件、目录的详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ll</span><br></pre></td></tr></table></figure></li>
<li><p>指定文件名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 当前目录下含有“test”的目录以及其详细信息</span><br><span class="line">ll test*</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-3-文件目录管理"><a href="#1-3-文件目录管理" class="headerlink" title="1.3. 文件目录管理"></a>1.3. 文件目录管理</h3><ol>
<li><p>创建目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir [list name]	</span><br></pre></td></tr></table></figure></li>
<li><p>删除空目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmdir [list name]	</span><br></pre></td></tr></table></figure></li>
<li><p>删除文件 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文件名需要和ls中的对应</span><br><span class="line">rm [file name] 	</span><br></pre></td></tr></table></figure></li>
<li><p>删除非空目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 目录可不为空 </span><br><span class="line"># r-表示循环 f-表示force强力</span><br><span class="line">rm -rf [list name]	</span><br></pre></td></tr></table></figure></li>
<li><p>复制目录或文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 复制文件 </span><br><span class="line"># 相对路径 or 绝对路径</span><br><span class="line">cp -r [origin file path] [destination file path]</span><br><span class="line"></span><br><span class="line"># 复制目录 </span><br><span class="line"># 相对路径 or 绝对路径</span><br><span class="line">cp -r [origin list path] [destination file path]</span><br></pre></td></tr></table></figure></li>
<li><p>移动目录或文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 移动文件 </span><br><span class="line"># 相对路径 or 绝对路径</span><br><span class="line">mv [origin file path] [destination file path]</span><br><span class="line"></span><br><span class="line"># 移动目录 </span><br><span class="line"># 相对路径 or 绝对路径</span><br><span class="line">mv [origin list path] [destination file path]</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-管理文件"><a href="#2-管理文件" class="headerlink" title="2. 管理文件"></a>2. 管理文件</h2><h3 id="2-1-创建文件"><a href="#2-1-创建文件" class="headerlink" title="2.1. 创建文件"></a>2.1. 创建文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在当前路径下创建一个名为[file name]的文件, 需要后缀</span><br><span class="line">touch [file name] 	</span><br></pre></td></tr></table></figure>





<h3 id="2-2-查看文件"><a href="#2-2-查看文件" class="headerlink" title="2.2. 查看文件"></a>2.2. 查看文件</h3><ol>
<li><p>显示文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat [file name]</span><br></pre></td></tr></table></figure></li>
<li><p>显示文件源码内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat -A [file name]</span><br></pre></td></tr></table></figure></li>
<li><p>按行显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一行一行显示文件内容</span><br><span class="line">more [file name]</span><br><span class="line"></span><br><span class="line"># 一行一行显示文件内容（可以翻页，但是没找到关闭的方式..）</span><br><span class="line">less [file name]</span><br></pre></td></tr></table></figure></li>
<li><p>显示部分内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示文件头几行，n表示显示的行数</span><br><span class="line">head -n [file name]	</span><br><span class="line"></span><br><span class="line"># 显示文件尾几行，n表示显示的行数</span><br><span class="line">tail -n [file name]	</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>卓越工程师</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>poj2182</title>
    <url>/2023/10/24/poj2182/</url>
    <content><![CDATA[<h1 id="POJ2182"><a href="#POJ2182" class="headerlink" title="POJ2182"></a>POJ2182</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 左移乘法，右移除法</span></span><br><span class="line"><span class="comment">    2. 移1位表示 *or/2，移2位表示 *or/4</span></span><br><span class="line"><span class="comment">    3. 移位运算一定要加括号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="comment">// len表示当前节点的长度</span></span><br><span class="line">    <span class="keyword">int</span> l, r, len; </span><br><span class="line">&#125;tree[N*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> pre[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立线段树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    tree[root].l = left; tree[root].r = right;</span><br><span class="line">    tree[root].len = right-left+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(left == right) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">build_tree</span>(root&lt;&lt;<span class="number">1</span>, left, (left+right)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build_tree</span>((root&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, ((left+right)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找当前节点下第k大的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quary</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    tree[root].len--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tree[root].l == tree[root].r) <span class="keyword">return</span> tree[root].l;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果左子树节点数量小于k，则从右子树寻找第 k-tree[root&lt;&lt;2].len 个元素</span></span><br><span class="line">    <span class="keyword">if</span>(tree[root&lt;&lt;<span class="number">1</span>].len&lt;k) <span class="keyword">return</span> <span class="built_in">quary</span>((root&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, k-tree[root&lt;&lt;<span class="number">1</span>].len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果大于k，表示左子树节点数量足够，继续从左子树寻找</span></span><br><span class="line">    <span class="keyword">if</span>(tree[root&lt;&lt;<span class="number">1</span>].len &gt;= k) <span class="keyword">return</span> <span class="built_in">quary</span>(root&lt;&lt;<span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pre[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build_tree</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        ans[i] = <span class="built_in">quary</span>(<span class="number">1</span>, pre[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">0 1 2 1 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树遍历</title>
    <url>/2021/10/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul>
<li><p>二叉树是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。</p>
</li>
<li><p>二叉树是一种更为典型的树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。</p>
</li>
</ul>
<p>定义二叉树的节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x, TreeNode *left, TreeNode right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>常见的二叉树遍历方式有<strong>前序遍历、中序遍历、后序遍历、层序遍历</strong>。下面实现二叉树遍历的四种方式：</p>
<h2 id="2-遍历方式"><a href="#2-遍历方式" class="headerlink" title="2. 遍历方式"></a>2. 遍历方式</h2><h3 id="2-1-前序遍历"><a href="#2-1-前序遍历" class="headerlink" title="2.1. 前序遍历"></a>2.1. 前序遍历</h3><p>前序遍历的顺序是 <strong>根节点-&gt;左节点-&gt;右节点</strong></p>
<p>下列二叉树的前序遍历为： A B D E C F</p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209090012434.png" alt="image-20211009130611162"></p>
<p><strong>递归实现</strong></p>
<p>利用递归实现前序遍历十分简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>栈实现方法</strong></p>
<p>利用栈实现前序遍历的核心是将树节点push到栈中然后在合适的时间从栈中弹出。</p>
<ul>
<li>首先将左节点push到栈中，push的同时访问当前节点数据。直到当前节点的左节点为nullptr。</li>
<li>判断栈是否为空，如果不为空就弹出当前栈顶节点，并push栈顶节点的右节点。</li>
<li>迭代上述操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; mySta;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !mySta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            mySta.<span class="built_in">push</span>(cur);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="comment">// mySta.push(cur);</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!mySta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cur = mySta.<span class="built_in">top</span>();</span><br><span class="line">            mySta.<span class="built_in">pop</span>();</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-中序遍历"><a href="#2-2-中序遍历" class="headerlink" title="2.2. 中序遍历"></a>2.2. 中序遍历</h3><p>中序遍历的顺序是 <strong>左节点-&gt;根节点-&gt;右节点</strong></p>
<p>下列二叉树的中序遍历为： D  B E A F C</p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209090013617.png" alt="image-20211009135839077"></p>
<p><strong>递归实现</strong></p>
<p>利用递归实现中序遍历十分简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>栈实现方法</strong></p>
<p>利用栈实现中序遍历的核心与前序遍历相同，只是需要注意访问节点数据的时机有所不同。</p>
<ul>
<li>首先将左节点push到栈中直到当前节点的左节点为nullptr。</li>
<li>判断栈是否为空，如果不为空就访问当前栈顶节点，并弹出当前栈顶节点，并push栈顶节点的右节点。</li>
<li>迭代上述操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; mySta;</span><br><span class="line">        <span class="comment">// mySta.push(root);</span></span><br><span class="line"></span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !mySta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                mySta.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!mySta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                cur = mySta.<span class="built_in">top</span>();</span><br><span class="line">                mySta.<span class="built_in">pop</span>();</span><br><span class="line">                ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-后序遍历"><a href="#2-3-后序遍历" class="headerlink" title="2.3. 后序遍历"></a>2.3. 后序遍历</h3><p>后序遍历的顺序是 <strong>左节点-&gt;右节点-&gt;根节点</strong></p>
<p>下列二叉树的后序遍历为： D E B F C A</p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209090014059.jpeg" alt="image-20211009140543901"></p>
<p><strong>递归实现</strong></p>
<p>利用递归实现前序遍历十分简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>栈实现方法</strong></p>
<p>利用栈实现二叉树的后序遍历的核心与前序遍历相同。但需要注意的是，如果直接使用栈来实现后序遍历会相对比较麻烦，因为需要控制第二次访问根节点才能将栈顶元素弹出，从而需要一个额外的栈来实现节点的访问计数。因此我将讨论后序遍历与前序遍历之间的关系，来寻找更加简便的方法。</p>
<p>根据前面的讨论我们可以得知 </p>
<ul>
<li><strong>前序遍历</strong>访问节点的顺序是 <strong>根节点-&gt;左节点-&gt;右节点</strong></li>
<li><strong>后序遍历</strong>访问节点的顺序是 <strong>左节点-&gt;右节点-&gt;根节点</strong></li>
</ul>
<p>假设我们将前序遍历的左右节点访问顺序交换，我们将会得到 <strong>根节点-&gt;右节点-&gt;左节点</strong> 的访问顺序。</p>
<p>接着将上述的顺序进行reverse。得到的顺序是 <strong>左节点-&gt;右节点-&gt;根节点</strong> 恰好和后序遍历的顺序相同。</p>
<p>因此我们只需要将前序遍历的栈实现方式中的所有<strong>左节点改为右节点</strong>，<strong>右节点改为左节点</strong>。同时在最后对结果进行<strong>reverse</strong>即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; mySta;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !mySta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            mySta.<span class="built_in">push</span>(cur);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="comment">// mySta.push(cur);</span></span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!mySta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cur = mySta.<span class="built_in">top</span>();</span><br><span class="line">            mySta.<span class="built_in">pop</span>();</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-层序遍历"><a href="#2-4-层序遍历" class="headerlink" title="2.4. 层序遍历"></a>2.4. 层序遍历</h3><p>层序遍历就是<strong>逐层遍历树结构</strong>。</p>
<p><strong>广度优先搜索</strong>是一种广泛运用在树或图这类数据结构中，遍历或搜索的算法。 该算法从一个根节点开始，首先访问节点本身。 然后遍历它的相邻节点，其次遍历它的二级邻节点、三级邻节点，以此类推。</p>
<p>当我们在树中进行广度优先搜索时，我们访问的节点的顺序是按照层序遍历顺序的。</p>
<p>下列二叉树的后序遍历为：A B C D E F</p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209090014780.png" alt="image-20211009142500875"></p>
<p><strong>广度优先搜索实现</strong></p>
<p>广度优先搜索的核心是<strong>队列</strong>。将队首元素出队，如果该节点有子节点则将子节点入队。直到队首节点没有子节点，并且队列中没有节点时，遍历结束。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; myQueue;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    myQueue.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!myQueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = myQueue.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;cnt; i++)&#123;</span><br><span class="line">            TreeNode *cur = myQueue.<span class="built_in">front</span>();</span><br><span class="line">            myQueue.<span class="built_in">pop</span>();</span><br><span class="line">            temp.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                myQueue.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                myQueue.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>历史散文、诗人</title>
    <url>/2021/10/04/%E5%8E%86%E5%8F%B2%E6%95%A3%E6%96%87%E3%80%81%E8%AF%97%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="历史散文、诗人"><a href="#历史散文、诗人" class="headerlink" title="历史散文、诗人"></a>历史散文、诗人</h1><h2 id="一、历史散文"><a href="#一、历史散文" class="headerlink" title="一、历史散文"></a>一、历史散文</h2><p><strong>《左传》：</strong>我国第一部叙事详细 形式完备的编年体史书。 （左丘明著）</p>
<p><strong>《春秋》：</strong>我国第一部编年体历史著作  （比左传早）</p>
<p><strong>《尚书》：</strong>我国第一部历史散文著作</p>
<p><strong>《国语》：</strong>我国第一部国别体史书。  （左丘明著）</p>
<p><strong>《战国策》：</strong>我国第一部国别体杂史。    （刘向著）</p>
<h2 id="二、屈原"><a href="#二、屈原" class="headerlink" title="二、屈原"></a>二、屈原</h2><ul>
<li><p>字原、名平。自称云名正则，字灵均。</p>
</li>
<li><p>楚辞体的创始人。</p>
</li>
<li><p>是我国第一个爱国主义诗人、我国第一个浪漫主义诗人。</p>
</li>
<li><p>是我国浪漫主义文学奠基人，开辟了“香草美人”的传统。</p>
</li>
<li><p>被称为辞赋之祖、中华诗祖。</p>
</li>
</ul>
<p><strong>代表作：</strong>《九章》、《九歌》、《天问》、《离骚》。</p>
<ul>
<li><p>《楚辞》是我国第一部浪漫主义诗歌总集，是我国浪漫主义文学源头。（不是屈原一人写）</p>
</li>
<li><p>《离骚》和《国风》并称风骚。</p>
</li>
<li><p>《离骚》是我国诗歌中最长的浪漫主义政治抒情诗！</p>
</li>
</ul>
<h2 id="三、西汉"><a href="#三、西汉" class="headerlink" title="三、西汉"></a>三、西汉</h2><ul>
<li><p>诗歌分为 汉乐府（五言为主）</p>
</li>
<li><p>《古诗十九首》为五言古诗体 被称为“一字千金”和“五言之冠冕”</p>
</li>
</ul>
<p><strong>汉乐府：</strong>汉代乐府机关</p>
<p><strong>汉乐府特色：</strong>以五言及杂言为主，口语化，题材叙事性，继承现代主义传统</p>
<p><strong>汉代四大家：</strong>司马相如、杨雄、班固、张衡。</p>
<p><strong>史书（司马光）：</strong>我国第一部纪传体通史。</p>
<ul>
<li>史书分为本纪 30世家、70列传、10表8书</li>
</ul>
<p><strong>汉书（班固）：</strong>我国第一部纪传体断代史。</p>
<p><strong>陌上桑语言特点：</strong>幽默诙谐，具有喜剧色彩，口语化，铺陈直叙的手法夸赞罗敷。</p>
<h2 id="四、李斯（秦代）"><a href="#四、李斯（秦代）" class="headerlink" title="四、李斯（秦代）"></a>四、李斯（秦代）</h2><ul>
<li><p>法家学派</p>
</li>
<li><p>被称为 “秦朝文学一枝独秀”。</p>
</li>
<li><p>谏逐客书选自《史书 李斯列传》 （是奏章体政论文/议论文）</p>
</li>
</ul>
<p><strong>四君：</strong>秦穆公、秦孝公、秦惠公、秦昭王。</p>
<p><strong>期：</strong>服丧一年 大功：服丧九个月 小功：服丧五个月</p>
<h2 id="五、陶渊明"><a href="#五、陶渊明" class="headerlink" title="五、陶渊明"></a>五、陶渊明</h2><ul>
<li><p>名潜、字元亮/渊明。私益号：靖节先生。自号：五柳先生。</p>
</li>
<li><p>田园诗创始人。</p>
</li>
<li><p>是我国最早大量创造田园诗的诗人。</p>
</li>
</ul>
<p><strong>称号：</strong>古今隐逸之宗/百世田园之主/千古隐逸之宗</p>
<p><strong>诗歌思想：</strong>厌倦官场、崇尚自然。</p>
<p><strong>诗歌风格：</strong>质朴自然、冲淡和平。</p>
<p><strong>诗歌特色：</strong>语言自然、朴素率真、善用白描、写意勾勒。</p>
<p><strong>文体：</strong>五言古体诗。</p>
<p><strong>题材：</strong>田园诗。</p>
<p><strong>作品集：</strong>《陶渊明集》</p>
<p><strong>代表作：</strong>《归园田居》、《桃花源记》、《归去来兮辞》</p>
<p><strong>山水诗开创者：</strong>谢灵运（谢康乐、大谢）、 谢朓（小谢）</p>
<ul>
<li>王国维在《人间词话》中说“无我之境，以物观物，故不知何者为我，何者为能”充分体现陶渊明《饮酒》诗歌的精神内涵</li>
</ul>
<h2 id="六、张若虚（初唐后期）"><a href="#六、张若虚（初唐后期）" class="headerlink" title="六、张若虚（初唐后期）"></a>六、张若虚（初唐后期）</h2><ul>
<li><p>“吴中四士”之一（张若虚、贺知章、包融、张旭）</p>
</li>
<li><p>张若虚现存诗歌：《代答闺梦还》、《春江花月夜》</p>
</li>
<li><p>文体：古乐府诗/旧题、七言古诗、长篇歌行体。</p>
</li>
<li><p>长篇歌行体 是鲍照创照（题目中有歌、行、谣、引 的乐府诗）</p>
</li>
<li><p>闻一多代表作：《死水》《红烛》</p>
</li>
<li><p>评价《春江花月夜》是“诗中的诗，顶峰中的顶峰”“孤篇压全答”“孤篇横绝，竞为大家”“圣唐/唐代第一诗”</p>
</li>
</ul>
<h2 id="七、李白（圣唐）"><a href="#七、李白（圣唐）" class="headerlink" title="七、李白（圣唐）"></a>七、李白（圣唐）</h2><ul>
<li><p>字太白、号青莲居士。诗仙，谪仙人。</p>
</li>
<li><p>浪漫主义诗人 。</p>
</li>
<li><p>诗歌：歌颂祖国大好河山，表现理想与现实的矛盾，风格豪放飘逸。</p>
</li>
<li><p>“唐代最伟大的诗人之一”</p>
</li>
</ul>
<p><strong>作品：</strong>《李太白集》</p>
<p><strong>古诗体：</strong>蜀道难、将进酒、梦游天老吟留别（楚词体）</p>
<p>​    宣州谢脁楼饯别校书叔云</p>
<p><strong>《行路难》文体：</strong>乐府古诗、歌行体、七言古诗。选自《李白集校注》</p>
<h2 id="八、王伟（盛唐）"><a href="#八、王伟（盛唐）" class="headerlink" title="八、王伟（盛唐）"></a>八、王伟（盛唐）</h2><ul>
<li><p>字摩诘（诗佛）</p>
</li>
<li><p>盛唐时期，山水田园诗派（描写自然风光，农村景象以及安逸恬淡的隐居生活，多用白描）</p>
</li>
<li><p>代表诗人：王维、孟浩然</p>
</li>
<li><p>被称为“天下之宗”。</p>
</li>
</ul>
<p><strong>作品集：</strong>《王右丞集》</p>
<p>苏轼评价王维诗歌：诗中有画，画中有诗</p>
<p>开创水墨山水画派</p>
]]></content>
      <categories>
        <category>hsy笔记</category>
      </categories>
      <tags>
        <tag>语文</tag>
        <tag>hsy</tag>
      </tags>
  </entry>
  <entry>
    <title>poj3468</title>
    <url>/2023/10/25/poj3468/</url>
    <content><![CDATA[<p><strong>Description</strong></p>
<p>You have <em>N</em> integers, <em>A</em>1, <em>A</em>2, … , <em>AN</em>. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval.</p>
<p><strong>Input</strong></p>
<p>The first line contains two numbers <em>N</em> and <em>Q</em>. 1 ≤ <em>N</em>,<em>Q</em> ≤ 100000.<br>The second line contains <em>N</em> numbers, the initial values of <em>A</em>1, <em>A</em>2, … , <em>AN</em>. -1000000000 ≤ <em>Ai</em> ≤ 1000000000.<br>Each of the next <em>Q</em> lines represents an operation.<br>“C <em>a</em> <em>b</em> <em>c</em>“ means adding <em>c</em> to each of <em>Aa</em>, <em>Aa</em>+1, … , <em>Ab</em>. -10000 ≤ <em>c</em> ≤ 10000.<br>“Q <em>a</em> <em>b</em>“ means querying the sum of <em>Aa</em>, <em>Aa</em>+1, … , <em>Ab</em>.</p>
<p><strong>Output</strong></p>
<p>You need to answer all <em>Q</em> commands in order. One answer in a line.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 5</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">Q 4 4</span><br><span class="line">Q 1 10</span><br><span class="line">Q 2 4</span><br><span class="line">C 3 6 3</span><br><span class="line">Q 2 4</span><br></pre></td></tr></table></figure>

<p><strong>Sample Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">55</span><br><span class="line">9</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<p><strong>Hint</strong></p>
<p>The sums may exceed the range of 32-bit integers.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max = <span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson rt&lt;&lt;1, l, mid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson (rt&lt;&lt;1)+1, mid+1, r</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    ll sum,add;</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;tree[Max&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;   <span class="comment">// 从下往上更新sum</span></span><br><span class="line">    tree[rt].sum = tree[rt&lt;&lt;<span class="number">1</span>].sum+tree[(rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123; <span class="comment">// 向下更新add和sum</span></span><br><span class="line">    <span class="keyword">if</span>(tree[rt].add!=<span class="number">0</span>)&#123;</span><br><span class="line">        tree[rt&lt;&lt;<span class="number">1</span>].add += tree[rt].add;</span><br><span class="line">        tree[(rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].add += tree[rt].add;</span><br><span class="line">        tree[rt&lt;&lt;<span class="number">1</span>].sum += (tree[rt&lt;&lt;<span class="number">1</span>].r-tree[rt&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>)*tree[rt].add;</span><br><span class="line">        tree[(rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].sum += (tree[(rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].r-tree[(rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].l+<span class="number">1</span>)*tree[rt].add;</span><br><span class="line">        tree[rt].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;   <span class="comment">// 建线段树</span></span><br><span class="line">    tree[rt].l = l; tree[rt].r = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;tree[rt].sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lson);</span><br><span class="line">    <span class="built_in">build</span>(rson);</span><br><span class="line">    <span class="built_in">push_up</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> a, <span class="keyword">int</span> b, ll c)</span></span>&#123;   <span class="comment">// 【a, b】区间每个数+c，使用lazy</span></span><br><span class="line">    <span class="keyword">if</span>(tree[rt].l&gt;=a &amp;&amp; tree[rt].r&lt;=b)&#123; <span class="comment">// 如果更新的区间 包含了 当前节点的区间</span></span><br><span class="line">        tree[rt].sum += (tree[rt].r-tree[rt].l+<span class="number">1</span>)*c;</span><br><span class="line">        tree[rt].add += c;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">push_down</span>(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[rt].l+tree[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= mid) <span class="built_in">update</span>(rt&lt;&lt;<span class="number">1</span>, a, b, c);</span><br><span class="line">    <span class="keyword">if</span>(b &gt; mid) <span class="built_in">update</span>((rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, a, b, c);</span><br><span class="line">    <span class="built_in">push_up</span>(rt);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quary</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;   <span class="comment">// 查询【Na, Nb】区间和</span></span><br><span class="line">    <span class="keyword">if</span>(tree[rt].l&gt;=a &amp;&amp; tree[rt].r&lt;=b)&#123; <span class="comment">// 如果更新的区间 包含了 当前节点的区间</span></span><br><span class="line">        <span class="keyword">return</span> tree[rt].sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">push_down</span>(rt);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[rt].l+tree[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= mid) ans += <span class="built_in">quary</span>(rt&lt;&lt;<span class="number">1</span>, a, b);</span><br><span class="line">    <span class="keyword">if</span>(b &gt; mid) ans += <span class="built_in">quary</span>((rt&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q, a, b;</span><br><span class="line">    ll c;</span><br><span class="line">    <span class="keyword">char</span> qu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cin &gt;&gt; n &gt;&gt; q;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n,&amp;q);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;qu);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(qu == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">quary</span>(<span class="number">1</span>, a, b));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;a,&amp;b, &amp;c);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, a, b, c);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 5</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line"><span class="comment">Q 4 4</span></span><br><span class="line"><span class="comment">Q 1 10</span></span><br><span class="line"><span class="comment">Q 2 4</span></span><br><span class="line"><span class="comment">C 3 6 3</span></span><br><span class="line"><span class="comment">Q 2 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">10 2</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line"><span class="comment">C 3 6 3</span></span><br><span class="line"><span class="comment">Q 2 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>区间求和</tag>
      </tags>
  </entry>
  <entry>
    <title>唐代诗人</title>
    <url>/2021/10/05/%E5%94%90%E4%BB%A3%E8%AF%97%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="唐代诗人"><a href="#唐代诗人" class="headerlink" title="唐代诗人"></a>唐代诗人</h1><h2 id="一、诗种类"><a href="#一、诗种类" class="headerlink" title="一、诗种类"></a>一、诗种类</h2><p><strong>古诗体：</strong></p>
<ul>
<li>没有严格的平仄、句数、字数、韵律要求。</li>
<li>以四言、五言、七言以及杂言为主。</li>
</ul>
<p><strong>近体诗（今体诗 格律诗）：</strong></p>
<ul>
<li>产生于隋唐，盛行于唐。</li>
<li>一种讲究平仄、对仗、押韵的诗歌体。</li>
<li>律诗和绝句的通称。</li>
</ul>
<p><strong>律诗：</strong></p>
<ul>
<li>四联（颔联首联颈联尾联）</li>
<li>颔联 颈联需要对仗、对偶。</li>
<li>严格的用韵要求</li>
</ul>
<p><strong>绝句：</strong>没有严格的用韵要求</p>
<h2 id="二、杜甫（盛唐）"><a href="#二、杜甫（盛唐）" class="headerlink" title="二、杜甫（盛唐）"></a>二、杜甫（盛唐）</h2><ul>
<li><p>杜少凌，杜工部，诗圣，诗歌界的孔子。</p>
</li>
<li><p>现实主义诗人。</p>
</li>
<li><p>诗歌深刻的反映了唐朝由盛转衰过程中的社会风貌和时代苦难。</p>
</li>
<li><p>其诗被被称为诗史。</p>
</li>
</ul>
<p><strong>诗歌风格：</strong>沉郁顿挫</p>
<p><strong>作品集：</strong>《杜少凌集》，《杜工部集》。</p>
<p><strong>作品：</strong>三吏三别、《新安吏》、《石壕吏》、《潼关吏》、《新婚别》、《无家别》、《垂老别》。</p>
<ul>
<li><p>《春望》感时花溅泪，恨别鸟惊心。 双关、五言律诗</p>
</li>
<li><p>《登高》老来多病，孤苦无依。 七言律诗</p>
</li>
</ul>
<p><strong>边塞诗派：</strong>高适、王昌龄、岑参。</p>
<h2 id="三、高适"><a href="#三、高适" class="headerlink" title="三、高适"></a>三、高适</h2><ul>
<li>子达夫</li>
</ul>
<p><strong>作品集：</strong>《高常侍集》</p>
<p><strong>作品：</strong>别董大、燕歌行。</p>
<h2 id="四、王昌龄"><a href="#四、王昌龄" class="headerlink" title="四、王昌龄"></a>四、王昌龄</h2><ul>
<li>字少伯</li>
</ul>
<p><strong>世称：</strong>王江宁、王龙标</p>
<p>“七绝圣手”、“诗歌夫子 王江宁”</p>
<p><strong>作品集：</strong>《王江宁集》</p>
<h2 id="五、岑参（岑家州）"><a href="#五、岑参（岑家州）" class="headerlink" title="五、岑参（岑家州）"></a>五、岑参（岑家州）</h2><p><strong>作品集：</strong>《岑家州集》</p>
<p><strong>作品：</strong>白雪歌送武判官归京</p>
<h2 id="六、白居易（中唐）"><a href="#六、白居易（中唐）" class="headerlink" title="六、白居易（中唐）"></a>六、白居易（中唐）</h2><ul>
<li><p>字乐天、号乐山居士、香山居士、江州司马、醉吟先生。</p>
</li>
<li><p>诗魔、诗王。</p>
</li>
<li><p>现代主义诗人。</p>
</li>
</ul>
<p><strong>主张：</strong>文章合为时而著，歌诗合为时而作。</p>
<p><strong>诗歌风格：</strong>平易晓畅（通俗易懂）</p>
<p><strong>作品集：</strong>《白氏长庆集》 “现存诗歌为唐人之冠”</p>
<p><strong>作品：</strong>琵琶行、长恨歌、卖炭翁、忆江南。</p>
<p><strong>新乐府：</strong>以新题写时事，不在以乐为标准。  首创为杜甫，“元白”倡导。</p>
<h2 id="七、韩愈"><a href="#七、韩愈" class="headerlink" title="七、韩愈"></a>七、韩愈</h2><ul>
<li><p>字退之，韩昌龄、韩文公。</p>
</li>
<li><p>崇尚秦汉散文、反对六朝骈俪文风。</p>
</li>
</ul>
<p><strong>古文运动：</strong>排斥道教、佛教、崇尚儒学。</p>
<p><strong>文学主张：</strong>言之有物、辞必己出、惟陈言之务去。 文道合一、文以顺从、文以载道。</p>
<p><strong>地位：</strong>唐宋散文八大家之一 、千古文章四大家之一<strong>（柳宗元、韩愈、苏轼、欧阳修）</strong></p>
<p><strong>作品集：</strong>《昌龄先生集》</p>
<h2 id="八、柳宗元"><a href="#八、柳宗元" class="headerlink" title="八、柳宗元"></a>八、柳宗元</h2><ul>
<li>字子厚、柳河东。</li>
<li>唐宋八大家之一 千古文章四大家之一</li>
<li>永州八记之首——始得西山宴游记</li>
</ul>
<p><strong>主张：</strong>针砭时弊，反对宦官专权、割据。反映民生疾苦，主张人以明道。</p>
<p><strong>寓言三则：</strong>哀溺之序、黔之驴、蝜蝂传.</p>
<p><strong>作品集：</strong>《柳河东集》</p>
<h2 id="九、刘禹锡"><a href="#九、刘禹锡" class="headerlink" title="九、刘禹锡"></a>九、刘禹锡</h2><ul>
<li><p>字梦得、刘宾客。</p>
</li>
<li><p>诗豪。 “刘白”——刘禹锡和白居易</p>
</li>
</ul>
<p><strong>风格：</strong>清新明朗</p>
<p>作品集：《刘宾客集》、《刘禹锡集》、《刘梦得集》</p>
<p><strong>作品：</strong>陋室铭 秋词 西山塞怀古</p>
<p>怀古或咏史诗都是用典和对比</p>
<h2 id="十、李商隐"><a href="#十、李商隐" class="headerlink" title="十、李商隐"></a>十、李商隐</h2><ul>
<li><p>字义山、号玉溪生、樊南生。</p>
</li>
<li><p>“小李杜”——李商隐、杜牧。</p>
</li>
<li><p>无题诗的开创人</p>
</li>
</ul>
<p><strong>风格：</strong>婉转缠绵、缠绵悱恻</p>
<p><strong>作品诗：</strong>《李义山集》、《樊南文集》</p>
<h2 id="十一、杜牧"><a href="#十一、杜牧" class="headerlink" title="十一、杜牧"></a>十一、杜牧</h2><ul>
<li>字牧之</li>
</ul>
<p><strong>作品集：</strong>《樊川文集》</p>
<p><strong>作品：</strong>清明、阿房宫赋、泊秦淮、赤壁。</p>
]]></content>
      <categories>
        <category>hsy笔记</category>
      </categories>
      <tags>
        <tag>语文</tag>
        <tag>hsy</tag>
      </tags>
  </entry>
  <entry>
    <title>文件管理器的java实现</title>
    <url>/2022/09/11/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="文件管理器的java实现"><a href="#文件管理器的java实现" class="headerlink" title="文件管理器的java实现"></a>文件管理器的java实现</h1><blockquote>
<p>github项目：<a href="https://github.com/xclovehsy/fileManage">https://github.com/xclovehsy/fileManage</a></p>
</blockquote>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><h3 id="1-1-项目需求"><a href="#1-1-项目需求" class="headerlink" title="1.1. 项目需求"></a>1.1. 项目需求</h3><p>运用面向对象程序设计思想，基于Java文件管理和I/O框架，实现基于图形界面的GUI文件管理器。</p>
<h3 id="1-2-实现功能"><a href="#1-2-实现功能" class="headerlink" title="1.2. 实现功能"></a>1.2. 实现功能</h3><ol>
<li>实现文件夹创建、删除、进入。</li>
<li>实现当前文件夹下的内容罗列。</li>
<li>实现文件拷贝和文件夹拷贝（文件夹拷贝指深度拷贝，包括所有子目录和文件）。</li>
<li>实现指定文件的加密和解密。</li>
<li>实现指定文件和文件夹的压缩。</li>
<li>实现压缩文件的解压。</li>
<li>文件管理器具有图形界面。</li>
</ol>
<h3 id="1-3-开发平台"><a href="#1-3-开发平台" class="headerlink" title="1.3. 开发平台"></a>1.3. 开发平台</h3><p><strong>开发语言：</strong><br>Java</p>
<p><strong>开发平台：</strong><br>Intellij IDEA 2021.2.2</p>
<h2 id="2-项目设计"><a href="#2-项目设计" class="headerlink" title="2. 项目设计"></a>2. 项目设计</h2><h3 id="2-1-MVC设计流程："><a href="#2-1-MVC设计流程：" class="headerlink" title="2.1. MVC设计流程："></a>2.1. MVC设计流程：</h3><p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021611627.gif" alt="img"></p>
<ol>
<li>MainFrame作为整个程序的主体，向用户展示GUI界面，同时接受用户的操作。通过响应事件调用FileManager中的文件操作方法，并从FileController中获取当前文件路径对GUI界面进行更新。</li>
<li>FileManager作为文件操作的主要对象，通过调用各种方法对文件进行操作，例如文件创建、删除、加密、解密等。</li>
<li>FileController中保存了文件管理器的当前节点信息以及各种设置信息，以提供MainFrame进行界面的更新。</li>
</ol>
<h3 id="2-2-程序架构设计"><a href="#2-2-程序架构设计" class="headerlink" title="2.2. 程序架构设计"></a>2.2. 程序架构设计</h3><h4 id="2-2-1-整体结构框架"><a href="#2-2-1-整体结构框架" class="headerlink" title="2.2.1. 整体结构框架"></a>2.2.1. 整体结构框架</h4><p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021612017.gif" alt="img"></p>
<hr>
<h4 id="2-2-2-View结构"><a href="#2-2-2-View结构" class="headerlink" title="2.2.2. View结构"></a>2.2.2. View结构</h4><ol>
<li>MyTable中包含了自己定义JTree中的部分构件；</li>
<li>MyTree中包含了自己定义的JTable中的部分构件；</li>
<li>MainFrame则为主界面使得程序具有图形界面，主界面分成了几个Panel和一个Menubar。其中ChangePositionPan负责文件管理器上方文本区域，以及跳转到对应文件夹或打开文件功能；</li>
<li>MyMenubar负责菜单栏的显示以及对应按钮的响应事件；</li>
<li>ReturnPanel中包含了两个按钮负责返回上一级界面以及磁盘界面；</li>
<li>TableScrollPanel通过JTable展示文件信息（名称、修改事件、类型、大小等）；</li>
<li>TreeScrollPanel通过JTree展示文件管理器的文件存储结构，并通过点击文件夹节点，使ManFrame界面跳转的对应的文件夹界面。</li>
</ol>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021612021.gif" alt="img"></p>
<p>对于Tree包，MyJTree负责显示目录树，MyJTreeNode负责构建目录树的结点并实现结点间的操作，而MyJTreeRender负责对目录树结点的图标渲染。</p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021612029.gif" alt="img"></p>
<p>对于Table包， MyJtableModel负责对数据进行整理，MyJTableCellRender负责对文件图标的渲染 </p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021612034.gif" alt="img"></p>
<hr>
<h4 id="2-2-3-FileOperation结构"><a href="#2-2-3-FileOperation结构" class="headerlink" title="2.2.3. FileOperation结构"></a>2.2.3. FileOperation结构</h4><p>这个包中的的程序主要负责对文件的操作，其中FileController中保存了文件管理器的当前节点信息以及各种设置信息，以提供MainFrame进行界面的更新；</p>
<ol>
<li>FileManager作为文件操作的主要对象，集成所有的文件操作，例如文件夹创建、删除、文件拷贝和文件夹拷贝等；</li>
<li>MainFrime通过调用FileManager中的方法间接调用其他几个类；</li>
<li>FileIcon负责获取文件的图标；</li>
<li>FileZip负责文件以及文件夹的压缩和解压缩；FileEncrypt通过IO流实现简单的文件加密操作； </li>
</ol>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021613183.gif" alt="img"></p>
<h3 id="2-3-UML类图"><a href="#2-3-UML类图" class="headerlink" title="2.3. UML类图"></a>2.3. UML类图</h3><p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021615668.jpg" alt="img"></p>
<h2 id="3-项目展示"><a href="#3-项目展示" class="headerlink" title="3. 项目展示"></a>3. 项目展示</h2><h3 id="3-1-主界面展示"><a href="#3-1-主界面展示" class="headerlink" title="3.1. 主界面展示"></a>3.1. 主界面展示</h3><p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021624967.gif" alt="img"></p>
<h3 id="3-2-创建、删除、进入"><a href="#3-2-创建、删除、进入" class="headerlink" title="3.2. 创建、删除、进入"></a>3.2. 创建、删除、进入</h3><p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021624582.gif" alt="img"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021625913.gif" alt="img"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021625247.gif" alt="img"></p>
<h3 id="3-3-隐藏文件"><a href="#3-3-隐藏文件" class="headerlink" title="3.3. 隐藏文件"></a>3.3. 隐藏文件</h3><p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021625083.gif" alt="img"></p>
<h3 id="3-4-文件压缩"><a href="#3-4-文件压缩" class="headerlink" title="3.4. 文件压缩"></a>3.4. 文件压缩</h3><p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209021626015.gif" alt="img"></p>
<hr>
<p>更多功能请查看说明文档</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络识别手写数字</title>
    <url>/2022/09/10/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="神经网络识别手写数字"><a href="#神经网络识别手写数字" class="headerlink" title="神经网络识别手写数字"></a>神经网络识别手写数字</h1><blockquote>
<p>github项目：<a href="https://github.com/xclovehsy/digitalRecANNs">https://github.com/xclovehsy/digitalRecANNs</a></p>
</blockquote>
<h2 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1. 项目简介"></a>1. 项目简介</h2><p>构建一个神经网络，利用梯度下降法实现参数的更新，最终实现对0-9的10个手写数字的识别。</p>
<p>其中，MNIST 数据集在 <a href="http://yann.lecun.com/exdb/mnist/">http://yann.lecun.com/exdb/mnist/</a> 获取, 它包含了四个部分:</p>
<ul>
<li>Training set images: train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本)</li>
<li>Training set labels: train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签)</li>
<li>Test set images: t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本)</li>
<li>Test set labels: t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签)</li>
</ul>
<h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><h3 id="2-1-数据与预处理"><a href="#2-1-数据与预处理" class="headerlink" title="2.1. 数据与预处理"></a>2.1. 数据与预处理</h3><p>MNIST手写数字图片集为60000条训练数据以及10000条测试数据。每一条为785个数字。每一条数据的第一个为数字的正确值，接下来的784个为图片的像素点，可以组成一篇28×28的像素的图片。数据预处理为纵向的784个数字矩阵，标签为纵向的10个数字，该每个数值介于0.01到0.99代表了识别为对应数字的概率。</p>
<h3 id="2-2-模型的构建"><a href="#2-2-模型的构建" class="headerlink" title="2.2. 模型的构建"></a>2.2. 模型的构建</h3><p>这里我采用三层的神经网络模型，即一个输入层、一个隐藏层、一个输出层。</p>
<h3 id="2-3-参数说明"><a href="#2-3-参数说明" class="headerlink" title="2.3. 参数说明"></a>2.3. 参数说明</h3><ul>
<li>Rate为神经网络模型梯度下降算法的学习率</li>
<li>epochs为神经网络模型训练的次数</li>
<li>input_num为神经网络模型的输入层节点数量即784个图片像素</li>
<li>hide_num为隐藏层节点数量</li>
<li>output_num为输出层节点数量</li>
<li>激活函数选用scipy中的expit函数</li>
</ul>
<h3 id="2-4-函数定义"><a href="#2-4-函数定义" class="headerlink" title="2.4. 函数定义"></a>2.4. 函数定义</h3><p>这里的神经网络模型主要有两个函数，一个训练函数net_train以及一个识别函数net_query。</p>
<ul>
<li><p>net_train训练函数通过传入的手写数字图片数据对神经网络模型进行训练，利用梯度下降算法对权重矩阵进行更新。识别函数通过图片数据以及神经网络模型进行计算的到对应数字的识别匹配概率。</p>
</li>
<li><p>load_mnist函数负责加载MNIST数据集中的数据，show_result函数随机获取测试集中的部分数字对神经网络模型的识别结果进行展示。</p>
</li>
</ul>
<h2 id="3-程序代码"><a href="#3-程序代码" class="headerlink" title="3. 程序代码"></a>3. 程序代码</h2><p>详细代码请查看：</p>
<blockquote>
<p>github项目：<a href="https://github.com/xclovehsy/digitalRecANNs">https://github.com/xclovehsy/digitalRecANNs</a></p>
</blockquote>
<h2 id="4-运行结果及分析"><a href="#4-运行结果及分析" class="headerlink" title="4. 运行结果及分析"></a>4. 运行结果及分析</h2><h3 id="4-1-运行结果"><a href="#4-1-运行结果" class="headerlink" title="4.1. 运行结果"></a>4.1. 运行结果</h3><p>当将神经网络训练次数设置为10时，训练测试神经网络模型结果如下，并给出测试集中随机20张手写数值识别结果如下；</p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209072154162.gif" alt="img"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209072154171.gif" alt="img"></p>
<h3 id="4-2-结果分析"><a href="#4-2-结果分析" class="headerlink" title="4.2. 结果分析"></a>4.2. 结果分析</h3><p>从实验结果可以看到，神经网络模型的正确识别率很高，在经过60000条数据训练后，识别的成功率高达95%以上。</p>
<p>将模型训练次数设置为1、5、10对神经网络模型进行训练并测试，可以看到当训练次数设置为1时，模型正确识别率为95.57%；当训练次数为5时，模型的正确识别率为97.23%；当训练次数设置为10时，模型的正确识别率为97.23%。</p>
<p>可以发现，模型识别的正确率随着模型训练次数的增加，在一定范围内增加。但是当超过一定的训练次数后，模型的识别正确率不会再增加，这有可能受限于神经网络的层数、隐藏层节点数量，以及手写数字图片的像素精度等因素。 </p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>anns</tag>
      </tags>
  </entry>
  <entry>
    <title>秦七子</title>
    <url>/2021/10/03/%E7%A7%A6%E4%B8%83%E5%AD%90/</url>
    <content><![CDATA[<h1 id="秦七子"><a href="#秦七子" class="headerlink" title="秦七子"></a>秦七子</h1><p><strong>老庄孔墨孟荀韩非 子（无列子）</strong></p>
<h2 id="一、老子（春秋末期）"><a href="#一、老子（春秋末期）" class="headerlink" title="一、老子（春秋末期）"></a>一、老子（春秋末期）</h2><ul>
<li><p>又称老聃，姓李、名耳、字伯阳。</p>
</li>
<li><p>道家学派创始人，与庄子合称为老庄。</p>
</li>
</ul>
<p><strong>核心思想：</strong>道法自然 贵柔守雌 无为而治 辩证法思想</p>
<p><strong>代表作：</strong>《老子》又称《道德经》万经之王 道德真经 德道经 五千言 老子五千文</p>
<p><strong>散文特点：</strong>具有深刻的哲理性和系统的思辨性</p>
<h2 id="二、庄子（战国中期）"><a href="#二、庄子（战国中期）" class="headerlink" title="二、庄子（战国中期）"></a>二、庄子（战国中期）</h2><ul>
<li><p>名周，字子休/沐。</p>
</li>
<li><p>道家学派 和老子合称老庄。</p>
</li>
</ul>
<p><strong>思想核心：</strong>顺其自然，提倡无为而不为。</p>
<p><strong>代表作：</strong>《庄子》又称《南华经》</p>
<p><strong>散文特点：</strong>构思精巧、想象丰富、文笔恣肆、词藻瑰丽、</p>
<p>​     采用寓言形式、善用连类比喻、富有浪漫色彩。</p>
<p><strong>“三玄”：</strong>《周易》《老子》《庄子》</p>
<p>秋水又名河泊与北海若</p>
<h2 id="三、孔子（春秋末期）"><a href="#三、孔子（春秋末期）" class="headerlink" title="三、孔子（春秋末期）"></a>三、孔子（春秋末期）</h2><ul>
<li><p>字丘，名仲尼。</p>
</li>
<li><p>儒家学派创始人。</p>
</li>
<li><p>被称为“大成至圣，万世师表”，开创讲学风气。</p>
</li>
</ul>
<p><strong>思想核心：</strong>仁和礼（克己复礼）</p>
<ul>
<li><p>代表作《论语》是其孔子弟子和再传弟子的语录体散文集</p>
</li>
<li><p>《论语》是我国最早的语录体散文集</p>
</li>
</ul>
<p><strong>散文特点：</strong>通俗易懂 善用修辞 具有格言色彩</p>
<p><strong>最高理想：</strong>大同</p>
<p><strong>教育思想：</strong>有教无类 因材施教</p>
<h2 id="四、孟子-战国中期）"><a href="#四、孟子-战国中期）" class="headerlink" title="四、孟子(战国中期）"></a>四、孟子(战国中期）</h2><ul>
<li>名轲，儒家学派，被称为亚圣。</li>
</ul>
<p><strong>思想核心：</strong>仁政和王道 主张名贵君轻的民本思想，反对暴政</p>
<p><strong>作品：</strong>《孟子》 </p>
<ul>
<li>《孟子》是孟子与其弟子共同编写 是论说体 多选题中也是语录体</li>
</ul>
<p><strong>散文特点：</strong>欲擒故纵，引君入豰的论辩思想，采用各种比喻增强辩论的形象性和说服力，大量运用排偶</p>
<h2 id="五、荀子"><a href="#五、荀子" class="headerlink" title="五、荀子"></a>五、荀子</h2><ul>
<li>名况，儒家学派。</li>
</ul>
<p><strong>核心思想：</strong>天行有常，人性本恶，重法爱民，隆礼敬士，人不可以已。</p>
<p><strong>代表作：</strong>《荀子》</p>
<h2 id="六、墨子"><a href="#六、墨子" class="headerlink" title="六、墨子"></a>六、墨子</h2><ul>
<li><p>名翟 </p>
</li>
<li><p>墨家代表</p>
</li>
</ul>
<p><strong>思想核心：</strong>兼爱 非攻 尚贤</p>
<p><strong>代表作：</strong>《墨子》</p>
<h2 id="七、韩非子"><a href="#七、韩非子" class="headerlink" title="七、韩非子"></a>七、韩非子</h2><ul>
<li>法家创始人</li>
</ul>
<p><strong>思想核心：</strong>法术势</p>
<p><strong>代表作：</strong>《韩非子》</p>
]]></content>
      <categories>
        <category>hsy笔记</category>
      </categories>
      <tags>
        <tag>语文</tag>
        <tag>hsy</tag>
      </tags>
  </entry>
  <entry>
    <title>组合逻辑电路</title>
    <url>/2021/10/09/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="组合逻辑电路"><a href="#组合逻辑电路" class="headerlink" title="组合逻辑电路"></a>组合逻辑电路</h1><h2 id="1-偶校验码生成器"><a href="#1-偶校验码生成器" class="headerlink" title="1. 偶校验码生成器"></a>1. 偶校验码生成器</h2><p><strong>设某数字系统的数据交换按半字节进行（传输数据为4位），同时保证数据交换的正确性，设计一个偶校验码生成器。</strong></p>
<p>通过查阅资料得知：奇偶校验码是一种增加二进制传输系统最小距离的简单和广泛采用的方法。是一种通过增加<strong>冗余位</strong>使得码字中”1”的个数恒为奇数或偶数的编码方法。</p>
<p>现在定义四位的数据输入（半字节）</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> [<span class="number">0</span>:<span class="number">3</span>]in;</span><br></pre></td></tr></table></figure>

<p>接着定义五位偶检验码的输出。其中前4位对应数据输入的4位信息元，最后为1位偶校验元</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">output</span> [<span class="number">0</span>:<span class="number">4</span>]out;</span><br></pre></td></tr></table></figure>

<p>五位偶检验码的前4位为对应4位数据数据，可以直接对应。通过计算可以推导出偶检验码的计算公式，偶检验码 r = a<sub>0</sub>⊕a<sub>1</sub>⊕a<sub>2</sub>⊕a<sub>3</sub> （奇检验码 r = a<sub>0</sub>⊕a<sub>1</sub>⊕a<sub>2</sub>⊕a<sub>3</sub>⊕1）,其中a<sub>i</sub>表示4位传输数据中对应的码元。在verilog中使用”^”表示异或运算。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">out[<span class="number">0</span>:<span class="number">3</span>] = in[<span class="number">0</span>:<span class="number">3</span>];   <span class="comment">//4位输出信息元对应4位传输数据</span></span><br><span class="line">out[<span class="number">4</span>] = in[<span class="number">0</span>]^in[<span class="number">1</span>]^in[<span class="number">2</span>]^in[<span class="number">3</span>];   <span class="comment">//偶校验元</span></span><br></pre></td></tr></table></figure>

<p>因此偶校验码生成器完整代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/100ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> pccg(in,out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> [<span class="number">0</span>:<span class="number">3</span>]in;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">0</span>:<span class="number">4</span>]out;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">assign</span> out[<span class="number">0</span>:<span class="number">3</span>] = in[<span class="number">0</span>:<span class="number">3</span>];   <span class="comment">//4位输出信息元对应4位传输数据</span></span><br><span class="line"><span class="keyword">assign</span> out[<span class="number">4</span>] = in[<span class="number">0</span>]^in[<span class="number">1</span>]^in[<span class="number">2</span>]^in[<span class="number">3</span>];   <span class="comment">//偶校验元</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><strong>vivado生成的电路图如下：</strong></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209090016846.png" alt="image-20211007213847079"></p>
<h2 id="2-命令启停器"><a href="#2-命令启停器" class="headerlink" title="2. 命令启停器"></a>2. 命令启停器</h2><p><strong>为computer house中烧咖啡的机器老鼠设计一个命令启停器。</strong></p>
<p>首先我定义一个总控制位En表示网关命令是否有效（1表示网关命令的有效，0表示网关命令无效）</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> En;</span><br></pre></td></tr></table></figure>

<p>通过题目得知网关命令中如果同时出现矛盾的命令对（F与B、I与S、TUON与TUOF）话，表示网关命令的无效。因此En应该如下表示：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">En = ~(F*B + I*S + TUON*TUOF);</span><br></pre></td></tr></table></figure>

<p>在老鼠四个动作行为中。老鼠的前进（A动作）、老鼠的后退（C动作）由En、F、B来控制，对应的真值表为：</p>
<table>
<thead>
<tr>
<th align="center">En</th>
<th align="center">F</th>
<th align="center">B</th>
<th align="center">A</th>
<th align="center">C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>其中x表示该位可以为“1”也可以为“0”。如果当F和B同时为1时，En为0。因此包含在第一中情况中。</p>
<p>写出对应的verilog语言为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">A = En*F</span><br><span class="line">C = En*B</span><br></pre></td></tr></table></figure>

<p>此外在老鼠四个动作行为中。咖啡的注入（D动作）、咖啡的停止注入（E动作）由En、I、S来控制，对应的真值表为：</p>
<table>
<thead>
<tr>
<th align="center">En</th>
<th align="center">I</th>
<th align="center">S</th>
<th align="center">D</th>
<th align="center">E</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>写出对应的verilog语言为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">D = En*I</span><br><span class="line">E = En*S</span><br></pre></td></tr></table></figure>

<p>因此烧咖啡机器老鼠的命令启停器的完整代码为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/100ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> controller(F, B, I, S, TUON, TUOF, A, C, D, E);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> F, B, I, S, TUON, TUOF;</span><br><span class="line"><span class="keyword">output</span> A, C, D, E;</span><br><span class="line"><span class="keyword">wire</span> En;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> En = ~(F*B + I*S + TUON*TUOF);</span><br><span class="line"><span class="keyword">assign</span> A = En*F;</span><br><span class="line"><span class="keyword">assign</span> C = En*B;</span><br><span class="line"><span class="keyword">assign</span> D = En*I;</span><br><span class="line"><span class="keyword">assign</span> E = En*S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><strong>通过vivado综合生成的电路图如下：</strong></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209090015765.png" alt="image-20211007225740825"></p>
]]></content>
      <categories>
        <category>数字逻辑</category>
      </categories>
      <tags>
        <tag>数字逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title>网络白板的java实现</title>
    <url>/2022/09/10/%E7%BD%91%E7%BB%9C%E7%99%BD%E6%9D%BF%E7%9A%84java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="网络白板的java实现"><a href="#网络白板的java实现" class="headerlink" title="网络白板的java实现"></a>网络白板的java实现</h1><blockquote>
<p>github项目：<a href="https://github.com/xclovehsy/whiteBoard">https://github.com/xclovehsy/whiteBoard</a></p>
</blockquote>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><h3 id="1-1-项目需求"><a href="#1-1-项目需求" class="headerlink" title="1.1. 项目需求"></a>1.1. 项目需求</h3><p>网络白板利用面相对象的思想设计适合可扩展的图形类集，利用java gui的mvc模式设计用户的绘图流程，利用java的套接字编程实现多客户端的数据共享方法，利用多线程机制实现绘图和数据传输的并发控制机制</p>
<h3 id="1-2-实现功能"><a href="#1-2-实现功能" class="headerlink" title="1.2. 实现功能"></a>1.2. 实现功能</h3><ol>
<li>程序能够在窗体上根据用户的选择绘制不同形状（3个以上）的图形；</li>
<li>程序能够修改图形的属性（颜色和大小）和位置（利用鼠标移动选定的图形）；</li>
<li>网络客户端的程序能够协同绘图（一个用户绘图其他用户均可见绘图效果）；</li>
<li>程序能够以文件的形式保存绘图结果，下次启动程序后能够读取绘图结果文件再现绘图效果。</li>
</ol>
<p><strong>开发语言：</strong><br>Java</p>
<p><strong>开发平台：</strong><br>Intellij IDEA 2021.2.2</p>
<h2 id="2-项目设计"><a href="#2-项目设计" class="headerlink" title="2. 项目设计"></a>2. 项目设计</h2><h3 id="2-1-MVC设计流程："><a href="#2-1-MVC设计流程：" class="headerlink" title="2.1. MVC设计流程："></a>2.1. MVC设计流程：</h3><p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061101956.gif" alt="img"></p>
<ol>
<li>GUIServer作为服务器接受客户端发送的图形数据，并将图形数据写入Data.txt文件中保存，同时将图形数据发送到各个客户端。</li>
<li>用户操作OpenGLApp画板。每画一个图形，程序会将数据发送到服务器。同时接受服务器传输的图形数据进行绘图。</li>
<li>Data.txt文件用于保存图形数据，每当服务器开启时将会读取文件中上次保存的图形数据，并发送到各个客户端进行绘图。</li>
</ol>
<h3 id="2-2-程序架构设计"><a href="#2-2-程序架构设计" class="headerlink" title="2.2. 程序架构设计"></a>2.2. 程序架构设计</h3><h4 id="2-2-1-整体结构框架"><a href="#2-2-1-整体结构框架" class="headerlink" title="2.2.1. 整体结构框架"></a>2.2.1. 整体结构框架</h4><p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061101514.gif" alt="img"></p>
<p>该程序代码共有三个部分</p>
<ol>
<li>app为网络白板客户的主程序</li>
<li>graph为图形包，里面包含了各种图形的数据，例如圆形、立方体、长方形等等。</li>
<li>server负责服务器数据的接受与发送，以及数据的保存</li>
<li>Data.txt用于保存图形数据</li>
</ol>
<hr>
<h4 id="2-2-2-app结构"><a href="#2-2-2-app结构" class="headerlink" title="2.2.2. app结构"></a>2.2.2. app结构</h4><p>OpenGLApp为网络白板客户端的主程序，负责GUI的显示，图形的绘制、发送数据、接受服务器发送的数据等，同时实现了1、根据用户的选择绘制不同形状（3个以上）的图形；2、修改图形的属性（颜色和大小）和位置（利用鼠标移动选定的图形）等功能。</p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061102231.gif" alt="img"></p>
<hr>
<h4 id="2-2-3-graph结构"><a href="#2-2-3-graph结构" class="headerlink" title="2.2.3. graph结构"></a>2.2.3. graph结构</h4><ol>
<li>Shape类是图形类的抽象父类, 它包含一个抽象方法draw(),在他的派生类中都实现了draw（）方法、各自的属性和属性的修改方法；</li>
<li>Graphic是用来存储当前已有的对象和绘制已有的对象；</li>
<li>Cube、Circle、Rectangle等均是Shape的子类。</li>
</ol>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061103998.gif" alt="img"></p>
<p><strong>Graph包类图如下（可见附件三）</strong></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061104406.jpg" alt="img"></p>
<hr>
<h4 id="2-2-4-server结构"><a href="#2-2-4-server结构" class="headerlink" title="2.2.4. server结构"></a>2.2.4. server结构</h4><ol>
<li>   GUIServer为服务器端，接受客户端发送的图形数据，并将图形数据写入Data.txt文件中保存。</li>
<li>   SeverThread多线程操作，可以并发的接受多个客户端的数据，并传送数据。</li>
</ol>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061105343.gif" alt="img"></p>
<h3 id="2-3-UML类图"><a href="#2-3-UML类图" class="headerlink" title="2.3. UML类图"></a>2.3. UML类图</h3><p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061105680.jpg" alt="img"></p>
<h2 id="3-项目展示"><a href="#3-项目展示" class="headerlink" title="3. 项目展示"></a>3. 项目展示</h2><h3 id="3-1-主界面"><a href="#3-1-主界面" class="headerlink" title="3.1. 主界面"></a>3.1. 主界面</h3><p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061106996.gif" alt="img"></p>
<h3 id="3-2-功能测试"><a href="#3-2-功能测试" class="headerlink" title="3.2. 功能测试"></a>3.2. 功能测试</h3><h4 id="3-2-1-绘制图形"><a href="#3-2-1-绘制图形" class="headerlink" title="3.2.1 绘制图形"></a>3.2.1 绘制图形</h4><p><strong>程序能够在窗体上根据用户的选择绘制不同形状（3个以上）的图形；</strong></p>
<p>该程序可以根据用户需要绘制不同的图形，通过点击面板上不同的图形按钮设置当前绘制的图形种类。例如圆形、椭圆、立方体、长方形、三角形等</p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061106005.gif" alt="img"></p>
<h4 id="3-2-2-修改图形"><a href="#3-2-2-修改图形" class="headerlink" title="3.2.2. 修改图形"></a>3.2.2. 修改图形</h4><p><strong>程序能够修改图形的属性（颜色和大小）和位置（利用鼠标移动选定的图形）；</strong></p>
<p>可以选择不同的线条颜色以及填充颜色</p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061106011.gif" alt="img"></p>
<h4 id="3-2-3-网络协同"><a href="#3-2-3-网络协同" class="headerlink" title="3.2.3. 网络协同"></a>3.2.3. 网络协同</h4><p><strong>网络客户端的程序能够协同绘图（一个用户绘图其他用户均可见绘图效果）；</strong></p>
<p>打开sever.GUISever服务器程序，等待其他画板的连接</p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061107060.gif" alt="img"></p>
<p>同时将网络白板客户端程序运行4次服务器连接上程序</p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061107064.gif" alt="img"></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061107082.gif" alt="img"></p>
<ul>
<li>在客户端1绘制图形将会传输其他客户端白板中。</li>
<li>在一个客户端中对图形进行修改，其他客户端的图形也会修改。即网络客户端的程序能够协同绘图（一个用户绘图其他用户均可见绘图效果）；</li>
</ul>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209061107093.gif" alt="img"></p>
<hr>
<p><strong>更多功能请查看说明文档</strong></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>诗经、楚辞</title>
    <url>/2021/10/04/%E8%AF%97%E7%BB%8F%E3%80%81%E6%A5%9A%E8%BE%9E/</url>
    <content><![CDATA[<h1 id="诗经、楚辞"><a href="#诗经、楚辞" class="headerlink" title="诗经、楚辞"></a>诗经、楚辞</h1><h2 id="一、诗经"><a href="#一、诗经" class="headerlink" title="一、诗经"></a>一、诗经</h2><ul>
<li><p>《诗经》又称《诗》和《诗三百》</p>
</li>
<li><p>是我国第一部（最早）现实主义诗歌总集 </p>
</li>
<li><p>记录了周初到周末500年历史</p>
</li>
<li><p>共305篇</p>
</li>
</ul>
<p><strong>诗经六义：</strong>风雅颂 赋比兴</p>
<p><strong>风（内容）</strong>：十五国风，共160篇。多用复沓手法，多为民歌。</p>
<p><strong>雅（题材）</strong>：《大雅》和《小雅》105篇 多为贵族宫廷乐曲。</p>
<p><strong>颂（音乐）</strong>：《周颂》、《商颂》、《鲁颂》</p>
<p><strong>赋</strong>：铺陈直叙。</p>
<p><strong>比</strong>：以彼物必此物。</p>
<p><strong>兴</strong>：借物比喻，触物兴词，以次及彼。</p>
<p><strong>《诗经》手法：</strong>重章叠句、情景交融、起兴手法、虚实结合。</p>
<p><strong>诗经艺术特色：</strong>以四言为主，重章叠句，节奏简约明快，情致回环往复 多用比兴手法，意蕴丰赡含蓄</p>
<ul>
<li><p>诗经中的国风被称为现代主义诗歌源头</p>
</li>
<li><p>王国维在《人间词话》评价蒹葭是“最得风人深致”</p>
</li>
</ul>
<h2 id="二、楚辞"><a href="#二、楚辞" class="headerlink" title="二、楚辞"></a>二、楚辞</h2><ul>
<li><p>是楚地民歌或者歌辞</p>
</li>
<li><p>楚辞体是一种新诗体，一般采用四言或八言</p>
</li>
</ul>
]]></content>
      <categories>
        <category>hsy笔记</category>
      </categories>
      <tags>
        <tag>语文</tag>
        <tag>hsy</tag>
      </tags>
  </entry>
  <entry>
    <title>遗传算法解决旅行商问题</title>
    <url>/2022/09/09/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="遗传算法解决旅行商问题"><a href="#遗传算法解决旅行商问题" class="headerlink" title="遗传算法解决旅行商问题"></a>遗传算法解决旅行商问题</h1><blockquote>
<p>github项目：<a href="https://github.com/xclovehsy/geneticAlgoTSP">https://github.com/xclovehsy/geneticAlgoTSP</a></p>
</blockquote>
<h2 id="1-项目描述"><a href="#1-项目描述" class="headerlink" title="1. 项目描述"></a>1. 项目描述</h2><p>一个旅行者需要到国内的10个城市旅行，各城市的坐标见cities.csv文档。请设计一个合理的线路使旅行者所行的路程之和最小。注意：每个城市只能访问一次，且最后要回到原来出来的城市。</p>
<h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2. 算法思路"></a>2. 算法思路</h2><p><strong>遗传算法</strong>是一种模仿自然界生物进化机制的全局搜索和优化方法。其具有以下几个基本的特征，接下来是对各个特征详细的说明。</p>
<ul>
<li><p><strong>表现型：</strong>旅行依次经过的城市，即旅行的路径。例如“重庆—&gt;北京—&gt;上海—&gt;天津—&gt;成都—&gt;… —&gt;重庆”这是一种旅行路径，这里需要注意的是最终需要回到起点。</p>
</li>
<li><p><strong>基因型：</strong>我根据cities.csv文件中的城市出现的顺序，对城市进行1.2.3….编码。然后旅行经过的城市依次以序号进行编码。同时因为最后要回到起点，因此起点和终点的序号应该相同。</p>
</li>
<li><p>这里我们根据cities.csv文件中城市的次序进行编码，即：北京-0、天津-1、上海-2、重庆-3、拉萨-4、乌鲁木齐-5、银川-6、呼和浩特-7、南宁-8、哈尔滨-9。</p>
</li>
<li><p><strong>编码：</strong>这里我选择的编码方式为：对城市进行1.2.3…次序编码，然后一条旅行路线为一个个体，编码方式为起点到终点依次经过城市的序号编码。 </p>
</li>
<li><p><strong>进化：</strong>种群逐渐适应生存环境，即总的路径长度不断得到缩小。旅行线路的进化是以种群的形式进行的。</p>
</li>
<li><p><strong>适应度：</strong>度量某个旅行线路对于生存环境的适应程度。这里我使用旅行线路总的路径长度倒数作为种群的适应度</p>
</li>
<li><p><strong>选择：</strong>以一定的概率从种群中选择若干个个体。我使用轮盘赌的方式对种群中的个体进行选择。</p>
</li>
<li><p><strong>交叉：</strong>两个旅行线路的某一相同位置处城市编码，前后两串分别交叉组合形成两个新的旅行线路。也称基因重组或杂交；</p>
</li>
<li><p><strong>变异：</strong>以一定的概率对种群中的个体进行基因突变，即随机选择个体基因中两个城市的编号进行交换。 </p>
</li>
</ul>
<h2 id="3-遗传算法步骤"><a href="#3-遗传算法步骤" class="headerlink" title="3. 遗传算法步骤"></a>3. 遗传算法步骤</h2><p>开始循环直至找到满意的解。</p>
<ol>
<li>评估每条染色体所对应个体的适应度。</li>
<li>遵照适应度越高，选择概率越大的原则，从种群中选择两个个体作为父方和母方。</li>
<li>抽取父母双方的染色体，进行交叉，产生子代。</li>
<li>对子代的染色体进行变异。</li>
<li>重复2，3，4步骤，直到新种群的产生。</li>
</ol>
<p>结束循环。</p>
<p><strong>算法流程图：</strong></p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209072116751.gif" alt="img"></p>
<h2 id="4-程序代码"><a href="#4-程序代码" class="headerlink" title="4. 程序代码"></a>4. 程序代码</h2><p>这里一共有三个模块分别是Life.py、GA.py、TSP.py，每个模块的作用如下：</p>
<ul>
<li>Life.py为种群中的旅游线路个体类，里面包含旅行路线的基因型以及适应值</li>
<li>GA.py为遗传算法内，里面主要包含了遗传算法的一些函数，例如基因交叉、基因突变、轮盘赌选择个体、生成个体、生成新一代种群等函数。</li>
<li>TSP.py为旅行商问题的主要运行模块，包含对城市数据的读取，计算适应值、绘制适应度函数的进化曲线和最终选择的线路图等功能。</li>
</ul>
<p>具体代码请查看目录“lab3”</p>
<h2 id="5-运行结果"><a href="#5-运行结果" class="headerlink" title="5. 运行结果"></a>5. 运行结果</h2><p>这里设置一个种群中包含20个体，迭代200次后计算得出最优路径。gen表示迭代到第i代种群，dis表示该种群中最优个体的总旅行距离。</p>
<p><strong>运行结果如下：</strong></p>
<p>gen:1, dis:150.1067758288992</p>
<p>gen:2, dis:150.1067758288992</p>
<p>…</p>
<p>gen:199, dis:109.98824625831303</p>
<p>gen:200, dis:109.98824625831303</p>
<hr>
<p>经历过200次迭代后，最短路径为：</p>
<p>北京——&gt;呼和浩特, dis:4.8935</p>
<p>呼和浩特——&gt;银川, dis:5.8709</p>
<p>银川——&gt;乌鲁木齐, dis:19.0424</p>
<p>乌鲁木齐——&gt;拉萨, dis:14.1505</p>
<p>拉萨——&gt;重庆, dis:15.4347</p>
<p>重庆——&gt;南宁, dis:6.9833</p>
<p>南宁——&gt;上海, dis:15.5932</p>
<p>上海——&gt;哈尔滨, dis:15.4157</p>
<p>哈尔滨——&gt;天津, dis:11.5217</p>
<p>天津——&gt;北京, dis:1.0825</p>
<p>最短路径距离为：109.9882</p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209072119886.gif" alt="img"></p>
<p>图2适应度函数的进化曲线</p>
<p><img src="https://xc-figure.oss-cn-hangzhou.aliyuncs.com/img/202209072119894.gif" alt="img"></p>
<p>图3最终选择的线路图</p>
<h2 id="6-结果分析"><a href="#6-结果分析" class="headerlink" title="6. 结果分析"></a>6. 结果分析</h2><p>由适应度函数的进化曲线可得知，刚开始种群进化速度很快，当适应值接近最优值时进化速度放缓。由图像可知在接近100代种群时适应值收敛。说明遗传的收敛效果良好。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>遗传算法</tag>
      </tags>
  </entry>
</search>
